<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>Recipes</title>
<style>
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*! normalize.css v2.1.2 | MIT License | git.io/normalize */
/* ========================================================================== HTML5 display definitions ========================================================================== */
/** Correct `block` display not defined in IE 8/9. */
@import url(http://cdnjs.cloudflare.com/ajax/libs/font-awesome/3.2.1/css/font-awesome.css);
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }

/** Correct `inline-block` display not defined in IE 8/9. */
audio, canvas, video { display: inline-block; }

/** Prevent modern browsers from displaying `audio` without controls. Remove excess height in iOS 5 devices. */
audio:not([controls]) { display: none; height: 0; }

/** Address `[hidden]` styling not present in IE 8/9. Hide the `template` element in IE, Safari, and Firefox < 22. */
[hidden], template { display: none; }

script { display: none !important; }

/* ========================================================================== Base ========================================================================== */
/** 1. Set default font family to sans-serif. 2. Prevent iOS text size adjust after orientation change, without disabling user zoom. */
html { font-family: sans-serif; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ }

/** Remove default margin. */
body { margin: 0; }

/* ========================================================================== Links ========================================================================== */
/** Remove the gray background color from active links in IE 10. */
a { background: transparent; }

/** Address `outline` inconsistency between Chrome and other browsers. */
a:focus { outline: thin dotted; }

/** Improve readability when focused and also mouse hovered in all browsers. */
a:active, a:hover { outline: 0; }

/* ========================================================================== Typography ========================================================================== */
/** Address variable `h1` font-size and margin within `section` and `article` contexts in Firefox 4+, Safari 5, and Chrome. */
h1 { font-size: 2em; margin: 0.67em 0; }

/** Address styling not present in IE 8/9, Safari 5, and Chrome. */
abbr[title] { border-bottom: 1px dotted; }

/** Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */
b, strong { font-weight: bold; }

/** Address styling not present in Safari 5 and Chrome. */
dfn { font-style: italic; }

/** Address differences between Firefox and other browsers. */
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }

/** Address styling not present in IE 8/9. */
mark { background: #ff0; color: #000; }

/** Correct font family set oddly in Safari 5 and Chrome. */
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }

/** Improve readability of pre-formatted text in all browsers. */
pre { white-space: pre-wrap; }

/** Set consistent quote types. */
q { quotes: "\201C" "\201D" "\2018" "\2019"; }

/** Address inconsistent and variable font size in all browsers. */
small { font-size: 80%; }

/** Prevent `sub` and `sup` affecting `line-height` in all browsers. */
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }

sup { top: -0.5em; }

sub { bottom: -0.25em; }

/* ========================================================================== Embedded content ========================================================================== */
/** Remove border when inside `a` element in IE 8/9. */
img { border: 0; }

/** Correct overflow displayed oddly in IE 9. */
svg:not(:root) { overflow: hidden; }

/* ========================================================================== Figures ========================================================================== */
/** Address margin not present in IE 8/9 and Safari 5. */
figure { margin: 0; }

/* ========================================================================== Forms ========================================================================== */
/** Define consistent border, margin, and padding. */
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }

/** 1. Correct `color` not being inherited in IE 8/9. 2. Remove padding so people aren't caught out if they zero out fieldsets. */
legend { border: 0; /* 1 */ padding: 0; /* 2 */ }

/** 1. Correct font family not being inherited in all browsers. 2. Correct font size not being inherited in all browsers. 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */
button, input, select, textarea { font-family: inherit; /* 1 */ font-size: 100%; /* 2 */ margin: 0; /* 3 */ }

/** Address Firefox 4+ setting `line-height` on `input` using `!important` in the UA stylesheet. */
button, input { line-height: normal; }

/** Address inconsistent `text-transform` inheritance for `button` and `select`. All other form control elements do not inherit `text-transform` values. Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. Correct `select` style inheritance in Firefox 4+ and Opera. */
button, select { text-transform: none; }

/** 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` and `video` controls. 2. Correct inability to style clickable `input` types in iOS. 3. Improve usability and consistency of cursor style between image-type `input` and others. */
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; /* 2 */ cursor: pointer; /* 3 */ }

/** Re-set default cursor for disabled elements. */
button[disabled], html input[disabled] { cursor: default; }

/** 1. Address box sizing set to `content-box` in IE 8/9. 2. Remove excess padding in IE 8/9. */
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ }

/** 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome (include `-moz` to future-proof). */
input[type="search"] { -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box; }

/** Remove inner padding and search cancel button in Safari 5 and Chrome on OS X. */
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }

/** Remove inner padding and border in Firefox 4+. */
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }

/** 1. Remove default vertical scrollbar in IE 8/9. 2. Improve readability and alignment in all browsers. */
textarea { overflow: auto; /* 1 */ vertical-align: top; /* 2 */ }

/* ========================================================================== Tables ========================================================================== */
/** Remove most spacing between table cells. */
table { border-collapse: collapse; border-spacing: 0; }

meta.foundation-mq-small { font-family: "only screen and (min-width: 768px)"; width: 768px; }

meta.foundation-mq-medium { font-family: "only screen and (min-width:1280px)"; width: 1280px; }

meta.foundation-mq-large { font-family: "only screen and (min-width:1440px)"; width: 1440px; }

*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }

html, body { font-size: 100%; }

body { background: white; color: #222222; padding: 0; margin: 0; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }

a:hover { cursor: pointer; }

img, object, embed { max-width: 100%; height: auto; }

object, embed { height: 100%; }

img { -ms-interpolation-mode: bicubic; }

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }

.left { float: left !important; }

.right { float: right !important; }

.text-left { text-align: left !important; }

.text-right { text-align: right !important; }

.text-center { text-align: center !important; }

.text-justify { text-align: justify !important; }

.hide { display: none; }

.antialiased, body { -webkit-font-smoothing: antialiased; }

img { display: inline-block; vertical-align: middle; }

textarea { height: auto; min-height: 50px; }

select { width: 100%; }

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }

.subheader, #content #toctitle, .admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .mathblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title, .tableblock > caption { line-height: 1.4; color: #6c818f; font-weight: 300; margin-top: 0.2em; margin-bottom: 0.5em; }

/* Typography resets */
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }

/* Default Link Styles */
a { color: #444444; text-decoration: underline; line-height: inherit; }
a:hover, a:focus { color: #111111; }
a img { border: none; }

/* Default paragraph styles */
p { font-family: inherit; font-weight: normal; font-size: 1em; line-height: 1.5; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }

/* Default header styles */
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: ff-meta-web-pro-1, ff-meta-web-pro-2, Arial, "Helvetica Neue", sans-serif; font-weight: bold; font-style: normal; color: #465158; text-rendering: optimizeLegibility; margin-top: 1em; margin-bottom: 0.5em; line-height: 1.2125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #909ea7; line-height: 0; }

h1 { font-size: 2.125em; }

h2 { font-size: 1.6875em; }

h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }

h4 { font-size: 1.125em; }

h5 { font-size: 1.125em; }

h6 { font-size: 1em; }

hr { border: solid #dddddd; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }

/* Helpful Typography Defaults */
em, i { font-style: italic; line-height: inherit; }

strong, b { font-weight: bold; line-height: inherit; }

small { font-size: 60%; line-height: inherit; }

code { font-family: "Consolas", "Deja Vu Sans Mono", "Bitstream Vera Sans Mono", monospace; font-weight: normal; color: #444444; }

/* Lists */
ul, ol, dl { font-size: 1em; line-height: 1.5; margin-bottom: 1.25em; list-style-position: outside; font-family: inherit; }

ul, ol { margin-left: 0; }
ul.no-bullet, ol.no-bullet { margin-left: 0; }

/* Unordered Lists */
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; /* Override nested font-size change */ }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }

/* Ordered Lists */
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }

/* Definition Lists */
dl dt { margin-bottom: 0.3em; font-weight: bold; }
dl dd { margin-bottom: 0.75em; }

/* Abbreviations */
abbr, acronym { text-transform: uppercase; font-size: 90%; color: black; border-bottom: 1px dotted #dddddd; cursor: help; }

abbr { text-transform: none; }

/* Blockquotes */
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
blockquote cite { display: block; font-size: 0.8125em; color: #748590; }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: #748590; }

blockquote, blockquote p { line-height: 1.5; color: #909ea7; }

/* Microformats */
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #dddddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }

.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }

@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
/* Print styles.  Inlined to avoid required HTTP connection: www.phpied.com/delay-loading-your-print-css/ Credit to Paul Irish and HTML5 Boilerplate (html5boilerplate.com)
*/
.print-only { display: none !important; }

@media print { * { background: transparent !important; color: #000 !important; /* Black prints faster: h5bp.com/s */ box-shadow: none !important; text-shadow: none !important; }
  a, a:visited { text-decoration: underline; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; page-break-inside: avoid; }
  thead { display: table-header-group; /* h5bp.com/t */ }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page { margin: 0.5cm; }
  p, h2, h3, #toctitle, .sidebarblock > .content > .title { orphans: 3; widows: 3; }
  h2, h3, #toctitle, .sidebarblock > .content > .title { page-break-after: avoid; }
  .hide-on-print { display: none !important; }
  .print-only { display: block !important; }
  .hide-for-print { display: none !important; }
  .show-for-print { display: inherit !important; } }
/* Tables */
table { background: white; margin-bottom: 1.25em; border: solid 0 #dddddd; }
table thead, table tfoot { background: none; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 1px 8px 1px 5px; font-size: 1em; color: #222222; text-align: left; }
table tr th, table tr td { padding: 1px 8px 1px 5px; font-size: 1em; color: #222222; }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: none; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.5; }

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }

*:not(pre) > code { font-size: 0.95em; padding: 0; white-space: nowrap; background-color: #f2f2f2; border: 0 solid #dddddd; -webkit-border-radius: 6px; border-radius: 6px; text-shadow: none; }

pre, pre > code { line-height: 1.2; color: inherit; font-family: "Consolas", "Deja Vu Sans Mono", "Bitstream Vera Sans Mono", monospace; font-weight: normal; }

.keyseq { color: #333333; }

kbd:not(.keyseq) { display: inline-block; color: black; font-size: 0.75em; line-height: 1.4; background-color: #F7F7F7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; margin: -0.15em 0.15em 0 0.15em; padding: 0.2em 0.6em 0.2em 0.5em; vertical-align: middle; white-space: nowrap; }

.keyseq kbd:first-child { margin-left: 0; }

.keyseq kbd:last-child { margin-right: 0; }

.menuseq, .menu { color: black; }

b.button:before, b.button:after { position: relative; top: -1px; font-weight: normal; }

b.button:before { content: "["; padding: 0 3px 0 2px; }

b.button:after { content: "]"; padding: 0 2px 0 3px; }

p a > code:hover { color: #373737; }

#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 0.9375em; padding-right: 0.9375em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }

#header { margin-bottom: 2.5em; }
#header > h1 { color: #111111; font-weight: bold; border-bottom: 1px solid #dddddd; margin-bottom: -28px; padding-bottom: 32px; }
#header span { color: #909ea7; }
#header #revnumber { text-transform: capitalize; }
#header br { display: none; }
#header br + span { padding-left: 3px; }
#header br + span:before { content: "\2013 \0020"; }
#header br + span.author { padding-left: 0; }
#header br + span.author:before { content: ", "; }

#toc { border-bottom: 1px solid #dddddd; padding-bottom: 1.25em; }
#toc > ul { margin-left: 0.25em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
#toc ul { list-style-type: none; }

#toctitle { color: #6c818f; }

@media only screen and (min-width: 768px) { body.toc2 { padding-left: 15em; padding-right: 0; }
  #toc.toc2 { position: fixed; width: 15em; left: 0; top: 0; border-right: 1px solid #dddddd; border-bottom: 0; z-index: 1000; padding: 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; font-size: 1.2em; }
  #toc.toc2 > ul { font-size: .90em; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 15em; }
  body.toc2.toc-right #toc.toc2 { border-right: 0; border-left: 1px solid #dddddd; left: auto; right: 0; } }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; padding-right: 0; }
  #toc.toc2 { width: 20em; }
  #toc.toc2 #toctitle { font-size: 1.375em; }
  #toc.toc2 > ul { font-size: 0.95em; }
  #toc.toc2 ul ul { padding-left: 1.25em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; border-width: 0; -webkit-border-radius: 6px; border-radius: 6px; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }
#content #toc a { text-decoration: none; }

#content #toctitle { font-weight: bold; font-family: ff-meta-web-pro-1, ff-meta-web-pro-2, Arial, "Helvetica Neue", sans-serif; font-size: 1em; padding-left: 0.125em; }

#footer { max-width: 100%; background-color: black; padding: 1.25em; }

#footer-text { color: white; line-height: 1.35; }

.sect1 { padding-bottom: 1.25em; }

.sect1 + .sect1 { border-top: 1px solid #dddddd; }

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; width: 1em; margin-left: -1em; display: block; text-decoration: none; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: '\00A7'; font-size: .85em; vertical-align: text-top; display: block; margin-top: 0.05em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: #465158; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #3b444a; }

.imageblock, .literalblock, .listingblock, .mathblock, .verseblock, .videoblock { margin-bottom: 1.25em; }

.admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .mathblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-align: left; font-weight: bold; }

.tableblock > caption { text-align: left; font-weight: bold; white-space: nowrap; overflow: visible; max-width: 0; }

table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }

.admonitionblock > table { border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: none; }
.admonitionblock > table td.icon .title { font-weight: bold; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #dddddd; color: #909ea7; }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }

.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: white; -webkit-border-radius: 6px; border-radius: 6px; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6, .exampleblock > .content p { color: #333333; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6 { line-height: 1; margin-bottom: 0.625em; }
.exampleblock > .content h1.subheader, .exampleblock > .content h2.subheader, .exampleblock > .content h3.subheader, .exampleblock > .content .subheader#toctitle, .sidebarblock.exampleblock > .content > .subheader.title, .exampleblock > .content h4.subheader, .exampleblock > .content h5.subheader, .exampleblock > .content h6.subheader { line-height: 1.4; }

.exampleblock.result > .content { -webkit-box-shadow: 0 1px 8px #d9d9d9; box-shadow: 0 1px 8px #d9d9d9; }

.sidebarblock { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; -webkit-border-radius: 6px; border-radius: 6px; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6, .sidebarblock p { color: #333333; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6 { line-height: 1; margin-bottom: 0.625em; }
.sidebarblock h1.subheader, .sidebarblock h2.subheader, .sidebarblock h3.subheader, .sidebarblock .subheader#toctitle, .sidebarblock > .content > .subheader.title, .sidebarblock h4.subheader, .sidebarblock h5.subheader, .sidebarblock h6.subheader { line-height: 1.4; }
.sidebarblock > .content > .title { color: #6c818f; margin-top: 0; line-height: 1.5; }

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }

.literalblock pre:not([class]), .listingblock pre:not([class]) { background: #eeeeee; }
.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { border-width: 1px; border-style: solid; border-color: #cccccc; -webkit-border-radius: 6px; border-radius: 6px; padding: 0.5em; word-wrap: break-word; }
.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
.literalblock pre > code, .literalblock pre[class] > code, .listingblock pre > code, .listingblock pre[class] > code { display: block; }
@media only screen { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 0.76em; } }
@media only screen and (min-width: 768px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 0.855em; } }
@media only screen and (min-width: 1280px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 0.95em; } }

.listingblock pre.highlight { padding: 0; }
.listingblock pre.highlight > code { padding: 0.5em; }

.listingblock > .content { position: relative; }

.listingblock:hover code[class*=" language-"]:before { text-transform: uppercase; font-size: 0.9em; color: #999; position: absolute; top: 0.375em; right: 0.375em; }

.listingblock:hover code.asciidoc:before { content: "asciidoc"; }
.listingblock:hover code.clojure:before { content: "clojure"; }
.listingblock:hover code.css:before { content: "css"; }
.listingblock:hover code.groovy:before { content: "groovy"; }
.listingblock:hover code.html:before { content: "html"; }
.listingblock:hover code.java:before { content: "java"; }
.listingblock:hover code.javascript:before { content: "javascript"; }
.listingblock:hover code.python:before { content: "python"; }
.listingblock:hover code.ruby:before { content: "ruby"; }
.listingblock:hover code.sass:before { content: "sass"; }
.listingblock:hover code.scss:before { content: "scss"; }
.listingblock:hover code.xml:before { content: "xml"; }
.listingblock:hover code.yaml:before { content: "yaml"; }

.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }

.listingblock.terminal pre .command:not([data-prompt]):before { content: '$'; }

table.pyhltable { border: 0; margin-bottom: 0; }

table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; }

table.pyhltable td.code { padding-left: .75em; padding-right: 0; }

.highlight.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #dddddd; }

.highlight.pygments .lineno { display: inline-block; margin-right: .25em; }

table.pyhltable .linenodiv { background-color: transparent !important; padding-right: 0 !important; }

.quoteblock { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
.quoteblock blockquote { margin: 0 0 1.25em 0; padding: 0 0 0.5625em 0; border: 0; }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: -.25em; padding-bottom: 0.5625em; font-size: 0.8125em; color: #748590; }
.quoteblock .attribution br { display: none; }
.quoteblock .attribution cite { display: block; margin-bottom: 0.625em; }

table thead th, table tfoot th { font-weight: bold; }

table.tableblock.grid-all { border-collapse: separate; border-spacing: 1px; -webkit-border-radius: 6px; border-radius: 6px; border-top: 0 solid #dddddd; border-bottom: 0 solid #dddddd; }

table.tableblock.frame-topbot, table.tableblock.frame-none { border-left: 0; border-right: 0; }

table.tableblock.frame-sides, table.tableblock.frame-none { border-top: 0; border-bottom: 0; }

table.tableblock td .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child { margin-bottom: 0; }

th.tableblock.halign-left, td.tableblock.halign-left { text-align: left; }

th.tableblock.halign-right, td.tableblock.halign-right { text-align: right; }

th.tableblock.halign-center, td.tableblock.halign-center { text-align: center; }

th.tableblock.valign-top, td.tableblock.valign-top { vertical-align: top; }

th.tableblock.valign-bottom, td.tableblock.valign-bottom { vertical-align: bottom; }

th.tableblock.valign-middle, td.tableblock.valign-middle { vertical-align: middle; }

tbody tr th { display: table-cell; line-height: 1.5; background: none; }

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: #222222; font-weight: bold; }

td > div.verse { white-space: pre; }

ol { margin-left: 0.25em; }

ul li ol { margin-left: 0; }

dl dd { margin-left: 1.125em; }

dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }

ul.unstyled, ol.unnumbered, ul.checklist, ul.none { list-style-type: none; }

ul.unstyled, ol.unnumbered, ul.checklist { margin-left: 0.625em; }

ul.checklist li > p:first-child > i[class^="icon-check"]:first-child, ul.checklist li > p:first-child > input[type="checkbox"]:first-child { margin-right: 0.25em; }

ul.checklist li > p:first-child > input[type="checkbox"]:first-child { position: relative; top: 1px; }

ul.inline { margin: 0 auto 0.625em auto; margin-left: -1.375em; margin-right: 0; padding: 0; list-style: none; overflow: hidden; }
ul.inline > li { list-style: none; float: left; margin-left: 1.375em; display: block; }
ul.inline > li > * { display: block; }

.unstyled dl dt { font-weight: normal; font-style: normal; }

ol.arabic { list-style-type: decimal; }

ol.decimal { list-style-type: decimal-leading-zero; }

ol.loweralpha { list-style-type: lower-alpha; }

ol.upperalpha { list-style-type: upper-alpha; }

ol.lowerroman { list-style-type: lower-roman; }

ol.upperroman { list-style-type: upper-roman; }

ol.lowergreek { list-style-type: lower-greek; }

.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }

td.hdlist1 { padding-right: .75em; font-weight: bold; }

td.hdlist1, td.hdlist2 { vertical-align: top; }

.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }

.colist > table tr > td:first-of-type { padding: 0 .75em; line-height: 1; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }

.qanda > ol > li > p > em:only-child { color: #373737; }

.thumb, .th { line-height: 0; display: inline-block; border: solid 4px white; -webkit-box-shadow: 0 0 0 1px #dddddd; box-shadow: 0 0 0 1px #dddddd; }

.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }

.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }

a.image { text-decoration: none; }

span.footnote, span.footnoteref { vertical-align: super; font-size: 0.875em; }
span.footnote a, span.footnoteref a { text-decoration: none; }

#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -.25em 0 .75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em; line-height: 1.3; font-size: 0.875em; margin-left: 1.2em; text-indent: -1.2em; margin-bottom: .2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }

#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }

.gist .file-data > table { border: none; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }

div.unbreakable { page-break-inside: avoid; }

.big { font-size: larger; }

.small { font-size: smaller; }

.underline { text-decoration: underline; }

.overline { text-decoration: overline; }

.line-through { text-decoration: line-through; }

.aqua { color: #00bfbf; }

.aqua-background { background-color: #00fafa; }

.black { color: black; }

.black-background { background-color: black; }

.blue { color: #0000bf; }

.blue-background { background-color: #0000fa; }

.fuchsia { color: #bf00bf; }

.fuchsia-background { background-color: #fa00fa; }

.gray { color: #606060; }

.gray-background { background-color: #7d7d7d; }

.green { color: #006000; }

.green-background { background-color: #007d00; }

.lime { color: #00bf00; }

.lime-background { background-color: #00fa00; }

.maroon { color: #600000; }

.maroon-background { background-color: #7d0000; }

.navy { color: #000060; }

.navy-background { background-color: #00007d; }

.olive { color: #606000; }

.olive-background { background-color: #7d7d00; }

.purple { color: #600060; }

.purple-background { background-color: #7d007d; }

.red { color: #bf0000; }

.red-background { background-color: #fa0000; }

.silver { color: #909090; }

.silver-background { background-color: #bcbcbc; }

.teal { color: #006060; }

.teal-background { background-color: #007d7d; }

.white { color: #bfbfbf; }

.white-background { background-color: #fafafa; }

.yellow { color: #bfbf00; }

.yellow-background { background-color: #fafa00; }

span.icon > [class^="icon-"], span.icon > [class*=" icon-"] { cursor: default; }

.admonitionblock td.icon [class^="icon-"]:before { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #444444; color: #333333; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }

.conum { display: inline-block; color: white !important; background-color: black; -webkit-border-radius: 100px; border-radius: 100px; text-align: center; width: 20px; height: 20px; font-size: 12px; font-weight: bold; line-height: 20px; font-family: Arial, sans-serif; font-style: normal; position: relative; top: -2px; letter-spacing: -1px; }
.conum * { color: white !important; }
.conum + b { display: none; }
.conum:after { content: attr(data-value); }
.conum:not([data-value]):empty { display: none; }

.listingblock code { white-space: pre; overflow: auto; overflow-wrap: normal; /* needed for webkit browsers */ }

#toc ul.sectlevel0 > li > a { font-style: normal; font-weight: bold; }

h4 { color: #6c818f; }

.literalblock > .content > pre, .listingblock > .content > pre { -webkit-border-radius: 6px; border-radius: 6px; margin-left: 2em; margin-right: 2em; }

.admonitionblock { margin-left: 2em; margin-right: 2em; }
.admonitionblock > table { border: 1px solid #609060; border-top-width: 1.5em; background-color: #e9ffe9; border-collapse: separate; -webkit-border-radius: 0; border-radius: 0; }
.admonitionblock > table td.icon { padding-top: .5em; padding-bottom: .5em; }
.admonitionblock > table td.content { padding: .5em 1em; color: black; font-size: .9em; border-left: none; }

.sidebarblock { background-color: #e8ecef; border-color: #ccc; }
.sidebarblock > .content > .title { color: #444444; }

table.tableblock.grid-all { border-collapse: collapse; -webkit-border-radius: 0; border-radius: 0; }
table.tableblock.grid-all th.tableblock, table.tableblock.grid-all td.tableblock { border-bottom: 1px solid #aaa; }

#footer { background-color: #465158; padding: 2em; }

#footer-text { color: #eee; font-size: 0.8em; text-align: center; }

.invisible {position: absolute; left: 9999px}
</style>
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel0">
<li><a href="#_recipes">Recipes</a></li>
<li><a href="#_traversal_recipes">Traversal Recipes</a>
<ul class="sectlevel1">
<li><a href="#between-vertices">Between Vertices</a></li>
<li><a href="#centrality">Centrality</a>
<ul class="sectlevel2">
<li><a href="#degree-centrality">Degree Centrality</a></li>
<li><a href="#betweeness-centrality">Betweeness Centrality</a></li>
<li><a href="#closeness-centrality">Closeness Centrality</a></li>
<li><a href="#eigenvector-centrality">Eigenvector Centrality</a></li>
</ul>
</li>
<li><a href="#connected-components">Connected Components</a></li>
<li><a href="#cycle-detection">Cycle Detection</a></li>
<li><a href="#duplicate-edge">Duplicate Edge Detection</a></li>
<li><a href="#duplicate-vertex">Duplicate Vertex Detection</a></li>
<li><a href="#if-then-based-grouping">If-Then Based Grouping</a></li>
<li><a href="#pagination">Pagination</a></li>
<li><a href="#recommendation">Recommendation</a></li>
<li><a href="#shortest-path">Shortest Path</a></li>
<li><a href="#traversal-induced-values">Traversal Induced Values</a></li>
<li><a href="#tree">Tree</a>
<ul class="sectlevel2">
<li><a href="#_lowest_common_ancestor">Lowest Common Ancestor</a></li>
<li><a href="#_maximum_depth">Maximum Depth</a></li>
<li><a href="#_time_based_indexing">Time-based Indexing</a></li>
</ul>
</li>
<li><a href="#olap-spark-yarn">OLAP traversals with Spark on YARN</a>
<ul class="sectlevel2">
<li><a href="#_approach">Approach</a></li>
<li><a href="#_prerequisites">Prerequisites</a></li>
<li><a href="#_running_the_job">Running the job</a></li>
<li><a href="#_explanation">Explanation</a></li>
<li><a href="#_additional_configuration_options">Additional configuration options</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_implementation_recipes">Implementation Recipes</a>
<ul class="sectlevel1">
<li><a href="#style-guide">Style Guide</a>
<ul class="sectlevel2">
<li><a href="#_style_guide_rules">Style Guide Rules</a></li>
</ul>
</li>
<li><a href="#traversal-component-reuse">Traversal Component Reuse</a></li>
</ul>
</li>
<li><a href="#contributing">How to Contribute a Recipe</a></li>
<li><a href="#_appendix">Appendix</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<a class="image" href="http://tinkerpop.apache.org"><img src="../images/apache-tinkerpop-logo.png" alt="apache tinkerpop logo" width="500"></a>
</div>
</div>
<div class="paragraph">
<p><strong>3.3.1</strong></p>
</div>
</div>
</div>
<h1 id="_recipes" class="sect0">Recipes</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p><span class="image" style="float: left"><img src="../images/gremlin-chef.png" alt="gremlin chef" width="120"></span> All programming languages tend to have
<a href="https://en.wikipedia.org/wiki/Software_design_pattern">patterns of usage</a> for commonly occurring problems. Gremlin
is not different in that respect. There are many commonly occurring traversal themes that have general applicability
to any graph. Gremlin Recipes present these common traversal patterns and methods of usage that will
provide some basic building blocks for virtually any graph in any domain.</p>
</div>
<div class="paragraph">
<p>Recipes assume general familiarity with Gremlin and the TinkerPop stack. Be sure to have read the
<a href="http://tinkerpop.apache.org/docs/3.3.1/tutorials/getting-started">Getting Started</a> tutorial and the
<a href="http://tinkerpop.apache.org/docs/3.3.1/tutorials/the-gremlin-console/">The Gremlin Console</a> tutorial.</p>
</div>
</div>
</div>
<h1 id="_traversal_recipes" class="sect0">Traversal Recipes</h1>
<div class="sect1">
<h2 id="between-vertices">Between Vertices</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is quite common to have a situation where there are two particular vertices of a graph and a need to execute some
traversal on the paths found between them. Consider the following examples using the modern toy graph:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V(<span class="integer">1</span>).bothE() <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
==&gt;e[<span class="integer">9</span>][<span class="integer">1</span>-created-&gt;<span class="integer">3</span>]
==&gt;e[<span class="integer">7</span>][<span class="integer">1</span>-knows-&gt;<span class="integer">2</span>]
==&gt;e[<span class="integer">8</span>][<span class="integer">1</span>-knows-&gt;<span class="integer">4</span>]
gremlin&gt; g.V(<span class="integer">1</span>).bothE().where(otherV().hasId(<span class="integer">2</span>)) <span class="invisible">//</span><b class="conum">2</b><span class="invisible">\</span>
==&gt;e[<span class="integer">7</span>][<span class="integer">1</span>-knows-&gt;<span class="integer">2</span>]
gremlin&gt; v1 = g.V(<span class="integer">1</span>).next();<span class="type">[]</span>
gremlin&gt; v2 = g.V(<span class="integer">2</span>).next();<span class="type">[]</span>
gremlin&gt; g.V(v1).bothE().where(otherV().is(v2)) <span class="invisible">//</span><b class="conum">3</b><span class="invisible">\</span>
==&gt;e[<span class="integer">7</span>][<span class="integer">1</span>-knows-&gt;<span class="integer">2</span>]
gremlin&gt; g.V(v1).outE().where(inV().is(v2)) <span class="invisible">//</span><b class="conum">4</b><span class="invisible">\</span>
==&gt;e[<span class="integer">7</span>][<span class="integer">1</span>-knows-&gt;<span class="integer">2</span>]
gremlin&gt; g.V(<span class="integer">1</span>).outE().where(inV().has(id, within(<span class="integer">2</span>,<span class="integer">3</span>))) <span class="invisible">//</span><b class="conum">5</b><span class="invisible">\</span>
==&gt;e[<span class="integer">9</span>][<span class="integer">1</span>-created-&gt;<span class="integer">3</span>]
==&gt;e[<span class="integer">7</span>][<span class="integer">1</span>-knows-&gt;<span class="integer">2</span>]
gremlin&gt; g.V(<span class="integer">1</span>).out().where(__.in().hasId(<span class="integer">6</span>)) <span class="invisible">//</span><b class="conum">6</b><span class="invisible">\</span>
==&gt;v[<span class="integer">3</span>]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>There are three edges from the vertex with the identifier of "1".</p>
</li>
<li>
<p>Filter those three edges using the <code>where()</code> step using the identifier of the vertex returned by <code>otherV()</code> to
ensure it matches on the vertex of concern, which is the one with an identifier of "2".</p>
</li>
<li>
<p>Note that the same traversal will work if there are actual <code>Vertex</code> instances rather than just vertex identifiers.</p>
</li>
<li>
<p>The vertex with identifier "1" has all outgoing edges, so it would also be acceptable to use the directional steps
of <code>outE()</code> and <code>inV()</code> since the schema allows it.</p>
</li>
<li>
<p>There is also no problem with filtering the terminating side of the traversal on multiple vertices, in this case,
vertices with identifiers "2" and "3".</p>
</li>
<li>
<p>There&#8217;s no reason why the same pattern of exclusion used for edges with <code>where()</code> can&#8217;t work for a vertex between
two vertices.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The basic pattern of using <code>where()</code> step to find the "other" known vertex can be applied in far more complex
scenarios. For one such example, consider the following traversal that finds all the paths between a group of defined
vertices:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; ids = [<span class="integer">2</span>,<span class="integer">4</span>,<span class="integer">6</span>].toArray()
==&gt;<span class="integer">2</span>
==&gt;<span class="integer">4</span>
==&gt;<span class="integer">6</span>
gremlin&gt; g.V(ids).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).
           repeat(bothE().otherV().simplePath()).times(<span class="integer">5</span>).emit(hasId(within(ids))).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).
           filter(select(last,<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).by(id).where(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>, lt(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>))).
           path().by().by(label)
==&gt;[v[<span class="integer">2</span>],knows,v[<span class="integer">1</span>],knows,v[<span class="integer">4</span>]]
==&gt;[v[<span class="integer">2</span>],knows,v[<span class="integer">1</span>],created,v[<span class="integer">3</span>],created,v[<span class="integer">4</span>]]
==&gt;[v[<span class="integer">2</span>],knows,v[<span class="integer">1</span>],created,v[<span class="integer">3</span>],created,v[<span class="integer">6</span>]]
==&gt;[v[<span class="integer">2</span>],knows,v[<span class="integer">1</span>],knows,v[<span class="integer">4</span>],created,v[<span class="integer">3</span>],created,v[<span class="integer">6</span>]]
==&gt;[v[<span class="integer">4</span>],created,v[<span class="integer">3</span>],created,v[<span class="integer">6</span>]]
==&gt;[v[<span class="integer">4</span>],knows,v[<span class="integer">1</span>],created,v[<span class="integer">3</span>],created,v[<span class="integer">6</span>]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>For another example, consider the following schema:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../images/recipe-job-schema.png" alt="recipe job schema" width="750"></span></p>
</div>
<div class="paragraph">
<p>Assume that the goal is to find information about a known job and a known person. Specifically, the idea would be
to extract the known job, the company that created the job, the date it was created by the company and whether or not
the known person completed an application.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">bob</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">bob</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">stephen</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">stephen</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">company</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Blueprints, Inc</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">blueprints</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">company</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Rexster, LLC</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">rexster</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">job</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">job1</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">blueprintsJob1</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">job</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">job2</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">blueprintsJob2</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">job</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">job3</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">blueprintsJob3</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">job</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">job4</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">rexsterJob1</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">application</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">application1</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">appBob1</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">application</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">application2</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">appBob2</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">application</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">application3</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">appStephen1</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">application</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">application4</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">appStephen2</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">completes</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">bob</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">appBob1</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">completes</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">bob</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">appBob2</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">completes</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">stephen</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">appStephen1</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">completes</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">stephen</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">appStephen2</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">appliesTo</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">appBob1</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">blueprintsJob1</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">appliesTo</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">appBob2</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">blueprintsJob2</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">appliesTo</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">appStephen1</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">rexsterJob1</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">appliesTo</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">appStephen2</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">blueprintsJob3</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">created</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">blueprints</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">blueprintsJob1</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">creationDate</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">12/20/2015</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">created</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">blueprints</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">blueprintsJob2</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">creationDate</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">12/15/2015</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">created</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">blueprints</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">blueprintsJob3</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">creationDate</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">12/16/2015</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">created</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">rexster</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">rexsterJob1</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">creationDate</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">12/18/2015</span><span class="delimiter">&quot;</span></span>).iterate()
gremlin&gt; vBlueprintsJob1 = g.V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">job</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">job1</span><span class="delimiter">&quot;</span></span>).next()
==&gt;v[<span class="integer">8</span>]
gremlin&gt; vRexsterJob1 = g.V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">job</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">job4</span><span class="delimiter">&quot;</span></span>).next()
==&gt;v[<span class="integer">14</span>]
gremlin&gt; vStephen = g.V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">stephen</span><span class="delimiter">&quot;</span></span>).next()
==&gt;v[<span class="integer">2</span>]
gremlin&gt; vBob = g.V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">bob</span><span class="delimiter">&quot;</span></span>).next()
==&gt;v[<span class="integer">0</span>]
gremlin&gt; g.V(vRexsterJob1).as(<span class="string"><span class="delimiter">'</span><span class="content">job</span><span class="delimiter">'</span></span>).
           inE(<span class="string"><span class="delimiter">'</span><span class="content">created</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">created</span><span class="delimiter">'</span></span>).
           outV().as(<span class="string"><span class="delimiter">'</span><span class="content">company</span><span class="delimiter">'</span></span>).
           select(<span class="string"><span class="delimiter">'</span><span class="content">job</span><span class="delimiter">'</span></span>).
           coalesce(__.in(<span class="string"><span class="delimiter">'</span><span class="content">appliesTo</span><span class="delimiter">'</span></span>).where(__.in(<span class="string"><span class="delimiter">'</span><span class="content">completes</span><span class="delimiter">'</span></span>).is(vStephen)),
                    constant(<span class="predefined-constant">false</span>)).as(<span class="string"><span class="delimiter">'</span><span class="content">application</span><span class="delimiter">'</span></span>).
           select(<span class="string"><span class="delimiter">'</span><span class="content">job</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">company</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">created</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">application</span><span class="delimiter">'</span></span>).
             by().by().by(<span class="string"><span class="delimiter">'</span><span class="content">creationDate</span><span class="delimiter">'</span></span>).by()
==&gt;[<span class="key">job</span>:v[<span class="integer">14</span>],<span class="key">company</span>:v[<span class="integer">6</span>],<span class="key">created</span>:<span class="integer">12</span>/<span class="integer">18</span>/<span class="integer">2015</span>,<span class="key">application</span>:v[<span class="integer">20</span>]]
gremlin&gt; g.V(vRexsterJob1, vBlueprintsJob1).as(<span class="string"><span class="delimiter">'</span><span class="content">job</span><span class="delimiter">'</span></span>).
           inE(<span class="string"><span class="delimiter">'</span><span class="content">created</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">created</span><span class="delimiter">'</span></span>).
           outV().as(<span class="string"><span class="delimiter">'</span><span class="content">company</span><span class="delimiter">'</span></span>).
           select(<span class="string"><span class="delimiter">'</span><span class="content">job</span><span class="delimiter">'</span></span>).
           coalesce(__.in(<span class="string"><span class="delimiter">'</span><span class="content">appliesTo</span><span class="delimiter">'</span></span>).where(__.in(<span class="string"><span class="delimiter">'</span><span class="content">completes</span><span class="delimiter">'</span></span>).is(vBob)),
                    constant(<span class="predefined-constant">false</span>)).as(<span class="string"><span class="delimiter">'</span><span class="content">application</span><span class="delimiter">'</span></span>).
           select(<span class="string"><span class="delimiter">'</span><span class="content">job</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">company</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">created</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">application</span><span class="delimiter">'</span></span>).
             by().by().by(<span class="string"><span class="delimiter">'</span><span class="content">creationDate</span><span class="delimiter">'</span></span>).by()
==&gt;[<span class="key">job</span>:v[<span class="integer">14</span>],<span class="key">company</span>:v[<span class="integer">6</span>],<span class="key">created</span>:<span class="integer">12</span>/<span class="integer">18</span>/<span class="integer">2015</span>,<span class="key">application</span>:<span class="predefined-constant">false</span>]
==&gt;[<span class="key">job</span>:v[<span class="integer">8</span>],<span class="key">company</span>:v[<span class="integer">4</span>],<span class="key">created</span>:<span class="integer">12</span>/<span class="integer">20</span>/<span class="integer">2015</span>,<span class="key">application</span>:v[<span class="integer">16</span>]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>While the traversals above are more complex, the pattern for finding "things" between two vertices is largely the same.
Note the use of the <code>where()</code> step to terminate the traversers for a specific user. It is embedded in a <code>coalesce()</code>
step to handle situations where the specified user did not complete an application for the specified job and will
return <code>false</code> in those cases.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="centrality">Centrality</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are many measures of <a href="https://en.wikipedia.org/wiki/Centrality">centrality</a> which are meant to help identify
the most important vertices in a graph. As these measures are common in graph theory, this section attempts to
demonstrate how some of these different indicators can be calculated using Gremlin.</p>
</div>
<div class="sect2">
<h3 id="degree-centrality">Degree Centrality</h3>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Centrality#Degree_centrality">Degree centrality</a> is a measure of the number of
edges associated to each vertex. The following examples use the modern toy graph:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().group().by().by(bothE().count()) <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
==&gt;[v[<span class="integer">1</span>]:<span class="integer">3</span>,v[<span class="integer">2</span>]:<span class="integer">1</span>,v[<span class="integer">3</span>]:<span class="integer">3</span>,v[<span class="integer">4</span>]:<span class="integer">3</span>,v[<span class="integer">5</span>]:<span class="integer">1</span>,v[<span class="integer">6</span>]:<span class="integer">1</span>]
gremlin&gt; g.V().group().by().by(inE().count()) <span class="invisible">//</span><b class="conum">2</b><span class="invisible">\</span>
==&gt;[v[<span class="integer">1</span>]:<span class="integer">0</span>,v[<span class="integer">2</span>]:<span class="integer">1</span>,v[<span class="integer">3</span>]:<span class="integer">3</span>,v[<span class="integer">4</span>]:<span class="integer">1</span>,v[<span class="integer">5</span>]:<span class="integer">1</span>,v[<span class="integer">6</span>]:<span class="integer">0</span>]
gremlin&gt; g.V().group().by().by(outE().count()) <span class="invisible">//</span><b class="conum">3</b><span class="invisible">\</span>
==&gt;[v[<span class="integer">1</span>]:<span class="integer">3</span>,v[<span class="integer">2</span>]:<span class="integer">0</span>,v[<span class="integer">3</span>]:<span class="integer">0</span>,v[<span class="integer">4</span>]:<span class="integer">2</span>,v[<span class="integer">5</span>]:<span class="integer">0</span>,v[<span class="integer">6</span>]:<span class="integer">1</span>]
gremlin&gt; g.V().project(<span class="string"><span class="delimiter">&quot;</span><span class="content">v</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">degree</span><span class="delimiter">&quot;</span></span>).by().by(bothE().count()) <span class="invisible">//</span><b class="conum">4</b><span class="invisible">\</span>
==&gt;[<span class="key">v</span>:v[<span class="integer">1</span>],<span class="key">degree</span>:<span class="integer">3</span>]
==&gt;[<span class="key">v</span>:v[<span class="integer">2</span>],<span class="key">degree</span>:<span class="integer">1</span>]
==&gt;[<span class="key">v</span>:v[<span class="integer">3</span>],<span class="key">degree</span>:<span class="integer">3</span>]
==&gt;[<span class="key">v</span>:v[<span class="integer">4</span>],<span class="key">degree</span>:<span class="integer">3</span>]
==&gt;[<span class="key">v</span>:v[<span class="integer">5</span>],<span class="key">degree</span>:<span class="integer">1</span>]
==&gt;[<span class="key">v</span>:v[<span class="integer">6</span>],<span class="key">degree</span>:<span class="integer">1</span>]
gremlin&gt; g.V().project(<span class="string"><span class="delimiter">&quot;</span><span class="content">v</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">degree</span><span class="delimiter">&quot;</span></span>).by().by(bothE().count()). <span class="invisible">//</span><b class="conum">5</b><span class="invisible">\</span>
           order().by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">degree</span><span class="delimiter">&quot;</span></span>), decr).
           limit(<span class="integer">4</span>)
==&gt;[<span class="key">v</span>:v[<span class="integer">1</span>],<span class="key">degree</span>:<span class="integer">3</span>]
==&gt;[<span class="key">v</span>:v[<span class="integer">3</span>],<span class="key">degree</span>:<span class="integer">3</span>]
==&gt;[<span class="key">v</span>:v[<span class="integer">4</span>],<span class="key">degree</span>:<span class="integer">3</span>]
==&gt;[<span class="key">v</span>:v[<span class="integer">2</span>],<span class="key">degree</span>:<span class="integer">1</span>]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Calculation of degree centrality which counts all incident edges on each vertex to include those that are both
incoming and outgoing.</p>
</li>
<li>
<p>Calculation of in-degree centrality which only counts incoming edges to a vertex.</p>
</li>
<li>
<p>Calculation of out-degree centrality which only counts outgoing edges from a vertex.</p>
</li>
<li>
<p>The previous examples all produce a single <code>Map</code> as their output. While that is a desirable output, producing a
stream of <code>Map</code> objects can allow some greater flexibility.</p>
</li>
<li>
<p>For example, use of a stream enables use of an ordered limit that can be executed in a distributed fashion in
OLAP traversals.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The <a href="http://tinkerpop.apache.org/docs/3.3.1/reference/#group-step">group</a> step takes up to two separate
<a href="http://tinkerpop.apache.org/docs/3.3.1/reference/#by-step">by</a> modulators. The first <code>by()</code> tells <code>group()</code>
what the key in the resulting <code>Map</code> will be (i.e. the value to group on). In the above examples, the <code>by()</code> is empty
and as a result, the grouping will be on the incoming <code>Vertex</code> object itself. The second <code>by()</code> is the value to be
stored in the <code>Map</code> for each key.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="betweeness-centrality">Betweeness Centrality</h3>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Betweenness_centrality">Betweeness centrality</a> is a measure of the number of times
a vertex is found between the <a href="#shortest-path">shortest path</a> of each vertex pair in a graph.  Consider the following
graph for demonstration purposes:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../images/betweeness-example.png" alt="betweeness example" width="600"></span></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.addV().property(id,<span class="string"><span class="delimiter">'</span><span class="content">A</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>).
           addV().property(id,<span class="string"><span class="delimiter">'</span><span class="content">B</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).
           addV().property(id,<span class="string"><span class="delimiter">'</span><span class="content">C</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span>).
           addV().property(id,<span class="string"><span class="delimiter">'</span><span class="content">D</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">d</span><span class="delimiter">'</span></span>).
           addV().property(id,<span class="string"><span class="delimiter">'</span><span class="content">E</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">e</span><span class="delimiter">'</span></span>).
           addV().property(id,<span class="string"><span class="delimiter">'</span><span class="content">F</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">f</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">next</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">next</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">next</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">d</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">next</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">e</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">next</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">d</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">e</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">next</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">e</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">f</span><span class="delimiter">'</span></span>).iterate()
gremlin&gt; g.V().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">v</span><span class="delimiter">&quot;</span></span>). <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
           repeat(both().simplePath().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">v</span><span class="delimiter">&quot;</span></span>)).emit(). <span class="invisible">//</span><b class="conum">2</b><span class="invisible">\</span>
           filter(project(<span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">y</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">z</span><span class="delimiter">&quot;</span></span>).by(select(first, <span class="string"><span class="delimiter">&quot;</span><span class="content">v</span><span class="delimiter">&quot;</span></span>)). <span class="invisible">//</span><b class="conum">3</b><span class="invisible">\</span>
                                       by(select(last, <span class="string"><span class="delimiter">&quot;</span><span class="content">v</span><span class="delimiter">&quot;</span></span>)).
                                       by(select(all, <span class="string"><span class="delimiter">&quot;</span><span class="content">v</span><span class="delimiter">&quot;</span></span>).count(local)).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">triple</span><span class="delimiter">&quot;</span></span>).
                  coalesce(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">y</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>). <span class="invisible">//</span><b class="conum">4</b><span class="invisible">\</span>
                             select(<span class="string"><span class="delimiter">&quot;</span><span class="content">triples</span><span class="delimiter">&quot;</span></span>).unfold().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>).
                             select(<span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">y</span><span class="delimiter">&quot;</span></span>).where(eq(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>)).
                             select(<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>),
                           store(<span class="string"><span class="delimiter">&quot;</span><span class="content">triples</span><span class="delimiter">&quot;</span></span>)). <span class="invisible">//</span><b class="conum">5</b><span class="invisible">\</span>
                  select(<span class="string"><span class="delimiter">&quot;</span><span class="content">z</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">length</span><span class="delimiter">&quot;</span></span>).
                  select(<span class="string"><span class="delimiter">&quot;</span><span class="content">triple</span><span class="delimiter">&quot;</span></span>).select(<span class="string"><span class="delimiter">&quot;</span><span class="content">z</span><span class="delimiter">&quot;</span></span>).where(eq(<span class="string"><span class="delimiter">&quot;</span><span class="content">length</span><span class="delimiter">&quot;</span></span>))). <span class="invisible">//</span><b class="conum">6</b><span class="invisible">\</span>
           select(all, <span class="string"><span class="delimiter">&quot;</span><span class="content">v</span><span class="delimiter">&quot;</span></span>).unfold(). <span class="invisible">//</span><b class="conum">7</b><span class="invisible">\</span>
           groupCount().next() <span class="invisible">//</span><b class="conum">8</b><span class="invisible">\</span>
==&gt;v[A]=<span class="integer">14</span>
==&gt;v[B]=<span class="integer">28</span>
==&gt;v[C]=<span class="integer">20</span>
==&gt;v[D]=<span class="integer">20</span>
==&gt;v[E]=<span class="integer">28</span>
==&gt;v[F]=<span class="integer">14</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Starting from each vertex in the graph&#8230;&#8203;</p>
</li>
<li>
<p>&#8230;&#8203;traverse on both - incoming and outgoing - edges, avoiding <a href="#cycle-detection">cyclic paths</a>.</p>
</li>
<li>
<p>Create a triple consisting of the first vertex, the last vertex and the length of the path between them.</p>
</li>
<li>
<p>Determine whether a path between those two vertices was already found.</p>
</li>
<li>
<p>If this is the first path between the two vertices, store the triple in an internal collection named "triples".</p>
</li>
<li>
<p>Keep only those paths between a pair of vertices that have the same length as the first path that was found between them.</p>
</li>
<li>
<p>Select all shortest paths and unfold them.</p>
</li>
<li>
<p>Count the number of occurrences of each vertex, which is ultimately its betweeness score.</p>
</li>
</ol>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Since the betweeness centrality algorithm requires the shortest path between any pair of vertices in the graph,
its practical applications are very limited. It&#8217;s recommended to use this algorithm only on small subgraphs (graphs like
the <a href="http://tinkerpop.apache.org/docs/current/reference/#grateful-dead">Grateful Dead graph</a> with only 808 vertices
and 8049 edges already require a massive amount of compute resources to determine the shortest paths between all vertex
pairs).
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="closeness-centrality">Closeness Centrality</h3>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Centrality">Closeness centrality</a> is a measure of the distance of one vertex to all
other reachable vertices in the graph. The following examples use the modern toy graph:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g = TinkerFactory.createModern().traversal()
==&gt;graphtraversalsource[tinkergraph[<span class="key">vertices</span>:<span class="integer">6</span> <span class="key">edges</span>:<span class="integer">6</span>], standard]
gremlin&gt; g.withSack(<span class="float">1f</span>).V().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">v</span><span class="delimiter">&quot;</span></span>). <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
           repeat(both().simplePath().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">v</span><span class="delimiter">&quot;</span></span>)).emit(). <span class="invisible">//</span><b class="conum">2</b><span class="invisible">\</span>
           filter(project(<span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">y</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">z</span><span class="delimiter">&quot;</span></span>).by(select(first, <span class="string"><span class="delimiter">&quot;</span><span class="content">v</span><span class="delimiter">&quot;</span></span>)). <span class="invisible">//</span><b class="conum">3</b><span class="invisible">\</span>
                                       by(select(last, <span class="string"><span class="delimiter">&quot;</span><span class="content">v</span><span class="delimiter">&quot;</span></span>)).
                                       by(select(all, <span class="string"><span class="delimiter">&quot;</span><span class="content">v</span><span class="delimiter">&quot;</span></span>).count(local)).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">triple</span><span class="delimiter">&quot;</span></span>).
                  coalesce(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">y</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>). <span class="invisible">//</span><b class="conum">4</b><span class="invisible">\</span>
                             select(<span class="string"><span class="delimiter">&quot;</span><span class="content">triples</span><span class="delimiter">&quot;</span></span>).unfold().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>).
                             select(<span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">y</span><span class="delimiter">&quot;</span></span>).where(eq(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>)).
                             select(<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>),
                           store(<span class="string"><span class="delimiter">&quot;</span><span class="content">triples</span><span class="delimiter">&quot;</span></span>)). <span class="invisible">//</span><b class="conum">5</b><span class="invisible">\</span>
                  select(<span class="string"><span class="delimiter">&quot;</span><span class="content">z</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">length</span><span class="delimiter">&quot;</span></span>).
                  select(<span class="string"><span class="delimiter">&quot;</span><span class="content">triple</span><span class="delimiter">&quot;</span></span>).select(<span class="string"><span class="delimiter">&quot;</span><span class="content">z</span><span class="delimiter">&quot;</span></span>).where(eq(<span class="string"><span class="delimiter">&quot;</span><span class="content">length</span><span class="delimiter">&quot;</span></span>))). <span class="invisible">//</span><b class="conum">6</b><span class="invisible">\</span>
           group().by(select(first, <span class="string"><span class="delimiter">&quot;</span><span class="content">v</span><span class="delimiter">&quot;</span></span>)). <span class="invisible">//</span><b class="conum">7</b><span class="invisible">\</span>
                   by(select(all, <span class="string"><span class="delimiter">&quot;</span><span class="content">v</span><span class="delimiter">&quot;</span></span>).count(local).sack(div).sack().sum()).next()
==&gt;v[<span class="integer">1</span>]=<span class="float">2.1666666666666665</span>
==&gt;v[<span class="integer">2</span>]=<span class="float">1.6666666666666665</span>
==&gt;v[<span class="integer">3</span>]=<span class="float">2.1666666666666665</span>
==&gt;v[<span class="integer">4</span>]=<span class="float">2.1666666666666665</span>
==&gt;v[<span class="integer">5</span>]=<span class="float">1.6666666666666665</span>
==&gt;v[<span class="integer">6</span>]=<span class="float">1.6666666666666665</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Defines a Gremlin <a href="http://tinkerpop.apache.org/docs/3.3.1/reference/#sack-step">sack</a> with a value of one.</p>
</li>
<li>
<p>Traverses on both - incoming and outgoing - edges, avoiding <a href="#cycle-detection">cyclic paths</a>.</p>
</li>
<li>
<p>Create a triple consisting of the first vertex, the last vertex and the length of the path between them.</p>
</li>
<li>
<p>Determine whether a path between those two vertices was already found.</p>
</li>
<li>
<p>If this is the first path between the two vertices, store the triple in an internal collection named "triples".</p>
</li>
<li>
<p>Keep only those paths between a pair of vertices that have the same length as the first path that was found between them.</p>
</li>
<li>
<p>For each vertex divide 1 by the product of the lengths of all shortest paths that start with this particular vertex.</p>
</li>
</ol>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Since the closeness centrality algorithm requires the shortest path between any pair of vertices in the graph,
its practical applications are very limited. It&#8217;s recommended to use this algorithm only on small subgraphs (graphs like
the <a href="http://tinkerpop.apache.org/docs/current/reference/#grateful-dead">Grateful Dead graph</a> with only 808 vertices
and 8049 edges already require a massive amount of compute resources to determine the shortest paths between all vertex
pairs).
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="eigenvector-centrality">Eigenvector Centrality</h3>
<div class="paragraph">
<p>A calculation of <a href="https://en.wikipedia.org/wiki/Centrality#Eigenvector_centrality">eigenvector centrality</a> uses the
relative importance of adjacent vertices to help determine their centrality. In other words, unlike
<a href="#degree-centrality">degree centrality</a> the vertex with the greatest number of incident edges does not necessarily
give it the highest rank. Consider the following example using the Grateful Dead graph:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; graph.io(graphml()).readGraph(<span class="string"><span class="delimiter">'</span><span class="content">data/grateful-dead.xml</span><span class="delimiter">'</span></span>)
gremlin&gt; g.V().repeat(groupCount(<span class="string"><span class="delimiter">'</span><span class="content">m</span><span class="delimiter">'</span></span>).by(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>).out()).times(<span class="integer">5</span>).cap(<span class="string"><span class="delimiter">'</span><span class="content">m</span><span class="delimiter">'</span></span>). <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
           order(local).by(values, decr).limit(local, <span class="integer">10</span>).next() <span class="invisible">//</span><b class="conum">2</b><span class="invisible">\</span>
==&gt;PLAYING IN THE BAND=<span class="integer">8758598</span>
==&gt;ME AND MY UNCLE=<span class="integer">8214246</span>
==&gt;JACK STRAW=<span class="integer">8173882</span>
==&gt;EL PASO=<span class="integer">7666994</span>
==&gt;TRUCKING=<span class="integer">7643494</span>
==&gt;PROMISED LAND=<span class="integer">7339027</span>
==&gt;CHINA CAT SUNFLOWER=<span class="integer">7322213</span>
==&gt;CUMBERLAND BLUES=<span class="integer">6730838</span>
==&gt;RAMBLE ON ROSE=<span class="integer">6676667</span>
==&gt;LOOKS LIKE RAIN=<span class="integer">6674121</span>
gremlin&gt; g.V().repeat(groupCount(<span class="string"><span class="delimiter">'</span><span class="content">m</span><span class="delimiter">'</span></span>).by(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>).out().timeLimit(<span class="integer">100</span>)).times(<span class="integer">5</span>).cap(<span class="string"><span class="delimiter">'</span><span class="content">m</span><span class="delimiter">'</span></span>). <span class="invisible">//</span><b class="conum">3</b><span class="invisible">\</span>
           order(local).by(values, decr).limit(local, <span class="integer">10</span>).next()
==&gt;PLAYING IN THE BAND=<span class="integer">8758598</span>
==&gt;ME AND MY UNCLE=<span class="integer">8214246</span>
==&gt;JACK STRAW=<span class="integer">8173882</span>
==&gt;EL PASO=<span class="integer">7666994</span>
==&gt;TRUCKING=<span class="integer">7643494</span>
==&gt;PROMISED LAND=<span class="integer">7339027</span>
==&gt;CHINA CAT SUNFLOWER=<span class="integer">7322213</span>
==&gt;CUMBERLAND BLUES=<span class="integer">6730838</span>
==&gt;RAMBLE ON ROSE=<span class="integer">6676667</span>
==&gt;LOOKS LIKE RAIN=<span class="integer">6674121</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The traversal iterates through each vertex in the graph and for each one repeatedly group counts each vertex that
passes through using the vertex as the key. The <code>Map</code> of this group count is stored in a variable named "m". The
<code>out()</code> traversal is repeated thirty times or until the paths are exhausted. Five iterations should provide enough
time to converge on a solution. Calling <code>cap('m')</code> at the end simply extracts the <code>Map</code> side-effect stored in "m".</p>
</li>
<li>
<p>The entries in the <code>Map</code> are then iterated and sorted with the top ten most central vertices presented as output.</p>
</li>
<li>
<p>The previous examples can be expanded on a little bit by including a
<a href="http://tinkerpop.apache.org/docs/current/reference/#timelimit-step">time limit</a>. The <code>timeLimit()</code> prevents the
traversal from taking longer than one hundred milliseconds to execute (the previous example takes considerably longer
than that). While the answer provided with the <code>timeLimit()</code> is not the absolute ranking, it does provide a relative
ranking that closely matches the absolute one. The use of <code>timeLimit()</code> in certain algorithms (e.g. recommendations)
can shorten the time required to get a reasonable and usable result.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="connected-components">Connected Components</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gremlin can be used to find <a href="https://en.wikipedia.org/wiki/Connected_component_(graph_theory)">connected components</a>
in a graph. Consider the following graph which has three connected components:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../images/connected-components.png" alt="connected components" width="600"></span></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.addV().property(id, <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).
           addV().property(id, <span class="string"><span class="delimiter">&quot;</span><span class="content">B</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).
           addV().property(id, <span class="string"><span class="delimiter">&quot;</span><span class="content">C</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>).
           addV().property(id, <span class="string"><span class="delimiter">&quot;</span><span class="content">D</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">d</span><span class="delimiter">&quot;</span></span>).
           addV().property(id, <span class="string"><span class="delimiter">&quot;</span><span class="content">E</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">e</span><span class="delimiter">&quot;</span></span>).
           addV().property(id, <span class="string"><span class="delimiter">&quot;</span><span class="content">F</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">link</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">link</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">link</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">d</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">e</span><span class="delimiter">&quot;</span></span>).iterate()</code></pre>
</div>
</div>
<div class="paragraph">
<p>One way to detect the various subgraphs would be to do something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().emit(cyclicPath().or().not(both())).repeat(both()).until(cyclicPath()). <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
           path().aggregate(<span class="string"><span class="delimiter">&quot;</span><span class="content">p</span><span class="delimiter">&quot;</span></span>). <span class="invisible">//</span><b class="conum">2</b><span class="invisible">\</span>
           unfold().dedup(). <span class="invisible">//</span><b class="conum">3</b><span class="invisible">\</span>
           map(__.as(<span class="string"><span class="delimiter">&quot;</span><span class="content">v</span><span class="delimiter">&quot;</span></span>).select(<span class="string"><span class="delimiter">&quot;</span><span class="content">p</span><span class="delimiter">&quot;</span></span>).unfold(). <span class="invisible">//</span><b class="conum">4</b><span class="invisible">\</span>
                  filter(unfold().where(eq(<span class="string"><span class="delimiter">&quot;</span><span class="content">v</span><span class="delimiter">&quot;</span></span>))).
                  unfold().dedup().order().by(id).fold()).
           dedup() <span class="invisible">//</span><b class="conum">5</b><span class="invisible">\</span>
==&gt;[v[A],v[B],v[C]]
==&gt;[v[D],v[E]]
==&gt;[v[F]]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Iterate all vertices and repeatedly traverse over both incoming and outgoing edges (TinkerPop doesn&#8217;t support
unidirectional graphs directly so it must be simulated by ignoring the direction with <code>both</code>). Note the use of <code>emit</code>
prior to <code>repeat</code> as this allows for return of a single length path.</p>
</li>
<li>
<p>Aggregate the <code>path()</code> of the emitted vertices to "p". It is within these paths that the list of connected
components will be identified. Obviously the paths list are duplicative in the sense that they contains different
paths traveled over the same vertices.</p>
</li>
<li>
<p>Unroll the elements in the path list with <code>unfold</code> and <code>dedup</code>.</p>
</li>
<li>
<p>Use the first vertex in each path to filter against the paths stored in "p". When a path is found that has the
vertex in it, dedup the vertices in the path, order it by the identifier. Each path output from this <code>map</code> step
represents a connected component.</p>
</li>
<li>
<p>The connected component list is duplicative given the nature of the paths in "p", but now that the vertices within
the paths are ordered, a final <code>dedup</code> will make the list of connective components unique.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This is a nice example of where running smaller pieces of a large Gremlin statement make it easier to see what
is happening at each step. Consider running this example one line at a time (or perhaps even in a step at a time) to
see the output at each point.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>While the above approach returns results nicely, the traversal doesn&#8217;t appear to work with OLAP. A less efficient
approach, but one more suited for OLAP execution looks quite similar but does not use <code>dedup</code> as heavily (thus
<code>GraphComputer</code> is forced to analyze far more paths):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.withComputer().V().emit(cyclicPath().or().not(both())).repeat(both()).until(cyclicPath()).
           aggregate(<span class="string"><span class="delimiter">&quot;</span><span class="content">p</span><span class="delimiter">&quot;</span></span>).by(path()).cap(<span class="string"><span class="delimiter">&quot;</span><span class="content">p</span><span class="delimiter">&quot;</span></span>).unfold().limit(local, <span class="integer">1</span>).
           map(__.as(<span class="string"><span class="delimiter">&quot;</span><span class="content">v</span><span class="delimiter">&quot;</span></span>).select(<span class="string"><span class="delimiter">&quot;</span><span class="content">p</span><span class="delimiter">&quot;</span></span>).unfold().
                  filter(unfold().where(eq(<span class="string"><span class="delimiter">&quot;</span><span class="content">v</span><span class="delimiter">&quot;</span></span>))).
                  unfold().dedup().order().by(id).fold()
           ).toSet()
==&gt;[v[A],v[B],v[C]]
==&gt;[v[D],v[E]]
==&gt;[v[F]]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cycle-detection">Cycle Detection</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A cycle occurs in a graph where a path loops back on itself to the originating vertex. For example, in the graph
depicted below Gremlin could be use to detect the cycle among vertices <code>A-B-C</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../images/graph-cycle.png" alt="graph cycle" width="250"></span></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.addV().property(id,<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>).
           addV().property(id,<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).
           addV().property(id,<span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span>).
           addV().property(id,<span class="string"><span class="delimiter">'</span><span class="content">d</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">d</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">d</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">d</span><span class="delimiter">'</span></span>).iterate()
gremlin&gt; g.V().as(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>).repeat(out().simplePath()).times(<span class="integer">2</span>).
           where(out().as(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>)).path() <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
==&gt;[v[a],v[b],v[c]]
==&gt;[v[b],v[c],v[a]]
==&gt;[v[c],v[a],v[b]]
gremlin&gt; g.V().as(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>).repeat(out().simplePath()).times(<span class="integer">2</span>).
           where(out().as(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>)).path().
           dedup().by(unfold().order().by(id).dedup().fold()) <span class="invisible">//</span><b class="conum">2</b><span class="invisible">\</span>
==&gt;[v[a],v[b],v[c]]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Gremlin starts its traversal from a vertex labeled "a" and traverses <code>out()</code> from each vertex filtering on the
<code>simplePath</code>, which removes paths with repeated objects. The steps going <code>out()</code> are repeated twice as in this case
the length of the cycle is known to be three and there is no need to exceed that. The traversal filters with a
<code>where()</code> to see only return paths that end with where it started at "a".</p>
</li>
<li>
<p>The previous query returned the <code>A-B-C</code> cycle, but it returned three paths which were all technically the same
cycle. It returned three, because there was one for each vertex that started the cycle (i.e. one for <code>A</code>, one for <code>B</code>
and one for <code>C</code>). This next line introduce deduplication to only return unique cycles.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The above case assumed that the need was to only detect cycles over a path length of three. It also respected the
directionality of the edges by only considering outgoing ones. What would need to change to detect cycles of
arbitrary length over both incoming and outgoing edges in the modern graph?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().as(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>).repeat(both().simplePath()).emit(loops().is(gt(<span class="integer">1</span>))).
           both().where(eq(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>)).path().
           dedup().by(unfold().order().by(id).dedup().fold())
==&gt;[v[<span class="integer">1</span>],v[<span class="integer">3</span>],v[<span class="integer">4</span>],v[<span class="integer">1</span>]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>An interesting type of cycle is known as the Eulerian circuit which is a path taken in a graph where each edge is
visited once and the path starts and ends with the same vertex. Consider the following graph, representative of an
imaginary but geographically similar <a href="https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg">Königsberg</a>
that happens to have an eighth bridge (the diagram depicts edge direction but direction won&#8217;t be considered in the traversal):</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../images/eulerian-circuit.png" alt="eulerian circuit" width="500"></span></p>
</div>
<div class="paragraph">
<p>Gremlin can detect if such a cycle exists with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.addV().property(id, <span class="string"><span class="delimiter">'</span><span class="content">blue</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).
           addV().property(id, <span class="string"><span class="delimiter">'</span><span class="content">orange</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">o</span><span class="delimiter">'</span></span>).
           addV().property(id, <span class="string"><span class="delimiter">'</span><span class="content">red</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">r</span><span class="delimiter">'</span></span>).
           addV().property(id, <span class="string"><span class="delimiter">'</span><span class="content">green</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">bridge</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">bridge</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">o</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">bridge</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">r</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">bridge</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">r</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">bridge</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">o</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">bridge</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">o</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">bridge</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">o</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">r</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">bridge</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">o</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">r</span><span class="delimiter">'</span></span>).iterate()
gremlin&gt; g.V().sideEffect(outE(<span class="string"><span class="delimiter">&quot;</span><span class="content">bridge</span><span class="delimiter">&quot;</span></span>).aggregate(<span class="string"><span class="delimiter">&quot;</span><span class="content">bridges</span><span class="delimiter">&quot;</span></span>)).barrier(). <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
           repeat(bothE(). <span class="invisible">//</span><b class="conum">2</b><span class="invisible">\</span>
                  or(__.not(select(<span class="string"><span class="delimiter">'</span><span class="content">e</span><span class="delimiter">'</span></span>)),
                     __.not(filter(__.as(<span class="string"><span class="delimiter">'</span><span class="content">x</span><span class="delimiter">'</span></span>).select(all, <span class="string"><span class="delimiter">'</span><span class="content">e</span><span class="delimiter">'</span></span>).unfold(). <span class="invisible">//</span><b class="conum">3</b><span class="invisible">\</span>
                            where(eq(<span class="string"><span class="delimiter">'</span><span class="content">x</span><span class="delimiter">'</span></span>))))).as(<span class="string"><span class="delimiter">'</span><span class="content">e</span><span class="delimiter">'</span></span>).
                  otherV()).
             until(select(all, <span class="string"><span class="delimiter">'</span><span class="content">e</span><span class="delimiter">'</span></span>).count(local).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>). <span class="invisible">//</span><b class="conum">4</b><span class="invisible">\</span>
                   select(<span class="string"><span class="delimiter">&quot;</span><span class="content">bridges</span><span class="delimiter">&quot;</span></span>).count(local).where(eq(<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>))).hasNext()
==&gt;<span class="predefined-constant">true</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Gather all the edges in a "bridges" side effect.</p>
</li>
<li>
<p>As mentioned earlier with the diagram, directionality is ignored as the traversal uses <code>bothE</code> and, later, <code>otherV</code>.</p>
</li>
<li>
<p>In continually traversing over both incoming and outgoing edges, this path is only worth continuing if the edges
traversed thus far are only traversed once. That set of edges is maintained in "e".</p>
</li>
<li>
<p>The traversal should repeat until the number of edges traversed in "e" is equal to the total number gathered in
the first step above, which would mean that the complete circuit has been made.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Unlike Königsberg, with just seven bridges, a Eulerian circuit exists in the case with an eighth bridge. The first
detected circuit can be displayed with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().sideEffect(outE(<span class="string"><span class="delimiter">&quot;</span><span class="content">bridge</span><span class="delimiter">&quot;</span></span>).aggregate(<span class="string"><span class="delimiter">&quot;</span><span class="content">bridges</span><span class="delimiter">&quot;</span></span>)).barrier().
           repeat(bothE().or(__.not(select(<span class="string"><span class="delimiter">'</span><span class="content">e</span><span class="delimiter">'</span></span>)),
                             __.not(filter(__.as(<span class="string"><span class="delimiter">'</span><span class="content">x</span><span class="delimiter">'</span></span>).select(all, <span class="string"><span class="delimiter">'</span><span class="content">e</span><span class="delimiter">'</span></span>).unfold().
                                    where(eq(<span class="string"><span class="delimiter">'</span><span class="content">x</span><span class="delimiter">'</span></span>))))).as(<span class="string"><span class="delimiter">'</span><span class="content">e</span><span class="delimiter">'</span></span>).otherV()).
             until(select(all, <span class="string"><span class="delimiter">'</span><span class="content">e</span><span class="delimiter">'</span></span>).count(local).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>).
                   select(<span class="string"><span class="delimiter">&quot;</span><span class="content">bridges</span><span class="delimiter">&quot;</span></span>).count(local).where(eq(<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>))).limit(<span class="integer">1</span>).
           path().by(id).by(constant(<span class="string"><span class="delimiter">&quot;</span><span class="content"> -&gt; </span><span class="delimiter">&quot;</span></span>)).
           map {<span class="predefined-type">String</span>.join(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>, <span class="local-variable">it</span>.get().objects())}
==&gt;orange -&gt; blue -&gt; green -&gt; orange -&gt; red -&gt; green -&gt; red -&gt; orange -&gt; blue</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="duplicate-edge">Duplicate Edge Detection</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Whether part of a graph maintenance process or for some other analysis need, it is sometimes necessary to detect
if there is more than one edge between two vertices. The following examples will assume that an edge with the same
label and direction will be considered "duplicate".</p>
</div>
<div class="paragraph">
<p>The "modern" graph does not have any duplicate edges that fit that definition, so the following example adds one
that is duplicative of the "created" edge between vertex "1" and "3".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V(<span class="integer">1</span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).V(<span class="integer">3</span>).addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">created</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).iterate()
gremlin&gt; g.V(<span class="integer">1</span>).outE(<span class="string"><span class="delimiter">&quot;</span><span class="content">created</span><span class="delimiter">&quot;</span></span>)
==&gt;e[<span class="integer">9</span>][<span class="integer">1</span>-created-&gt;<span class="integer">3</span>]
==&gt;e[<span class="integer">13</span>][<span class="integer">1</span>-created-&gt;<span class="integer">3</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>One way to find the duplicate edges would be to do something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().outE().
           project(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>). <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
             by().by(inV().path().by().by(label)).
           group(). <span class="invisible">//</span><b class="conum">2</b><span class="invisible">\</span>
             by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>)).
             by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).fold()).
           unfold(). <span class="invisible">//</span><b class="conum">3</b><span class="invisible">\</span>
           select(values). <span class="invisible">//</span><b class="conum">4</b><span class="invisible">\</span>
           where(count(local).is(gt(<span class="integer">1</span>)))
==&gt;[e[<span class="integer">9</span>][<span class="integer">1</span>-created-&gt;<span class="integer">3</span>],e[<span class="integer">13</span>][<span class="integer">1</span>-created-&gt;<span class="integer">3</span>]]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The "a" and "b" from the <code>project</code> contain the edge and the path respectively. The path consists of a the outgoing
vertex, an edge, and the incoming vertex. The use of <code>by().by(label))</code> converts the edge to its label (recall that <code>by</code>
are applied in round-robin fashion), so the path will look something like: <code>[v[1],created,v[3]]</code>.</p>
</li>
<li>
<p>Group by the path from "b" and construct a list of edges from "a". Any value in this <code>Map</code> that has a list of edges
greater than one means that there is more than one edge for that edge label between those two vertices (i.e. the <code>Map</code>
key).</p>
</li>
<li>
<p>Unroll the key-value pairs in the <code>Map</code> of paths-edges.</p>
</li>
<li>
<p>Only the values from the <code>Map</code> are needed and as mentioned earlier, those lists with more than one edge would
contain  duplicate.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This method find the duplicates, but does require more memory than other approaches. A slightly more complex approach
that uses less memory might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">ov</span><span class="delimiter">&quot;</span></span>).
           outE().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">e</span><span class="delimiter">&quot;</span></span>).
           inV().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">iv</span><span class="delimiter">&quot;</span></span>).
           inE(). <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
           where(neq(<span class="string"><span class="delimiter">&quot;</span><span class="content">e</span><span class="delimiter">&quot;</span></span>)). <span class="invisible">//</span><b class="conum">2</b><span class="invisible">\</span>
           where(eq(<span class="string"><span class="delimiter">&quot;</span><span class="content">e</span><span class="delimiter">&quot;</span></span>)).by(label).
           where(outV().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">ov</span><span class="delimiter">&quot;</span></span>)).
           group().
             by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">ov</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">e</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">iv</span><span class="delimiter">&quot;</span></span>).by().by(label)). <span class="invisible">//</span><b class="conum">3</b><span class="invisible">\</span>
           unfold(). <span class="invisible">//</span><b class="conum">4</b><span class="invisible">\</span>
           select(values).
           where(count(local).is(gt(<span class="integer">1</span>)))
==&gt;[e[<span class="integer">13</span>][<span class="integer">1</span>-created-&gt;<span class="integer">3</span>],e[<span class="integer">9</span>][<span class="integer">1</span>-created-&gt;<span class="integer">3</span>]]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>To this point in the traversal, the outgoing edges of a vertex are being iterated with the current edge labeled
as "e". For "e", Gremlin traverses to the incoming vertex and back on in edges of that vertex.</p>
</li>
<li>
<p>Those incoming edges are filtered with the following <code>where</code> steps. The first ensures that it does not traverse
back over "e" (i.e. the current edge). The second determines if the edge label is equivalent (i.e. the test for the
working definition of "duplicate"). The third determines if the outgoing vertex matches the one that started the
path labeled as "ov".</p>
</li>
<li>
<p>This line is quite similar to the output achieved in the previous example at step 2. A <code>Map</code> is produced that uses
the outgoing vertex, the edge label, and the incoming vertex as the key, with the list of edges for that path as the
value.</p>
</li>
<li>
<p>The rest of the traversal is the same as the previous one.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that the above traversal could also be written using <code>match</code> step:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().match(
             __.as(<span class="string"><span class="delimiter">&quot;</span><span class="content">ov</span><span class="delimiter">&quot;</span></span>).outE().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">e</span><span class="delimiter">&quot;</span></span>),
             __.as(<span class="string"><span class="delimiter">&quot;</span><span class="content">e</span><span class="delimiter">&quot;</span></span>).inV().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">iv</span><span class="delimiter">&quot;</span></span>),
             __.as(<span class="string"><span class="delimiter">&quot;</span><span class="content">iv</span><span class="delimiter">&quot;</span></span>).inE().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">ie</span><span class="delimiter">&quot;</span></span>),
             __.as(<span class="string"><span class="delimiter">&quot;</span><span class="content">ie</span><span class="delimiter">&quot;</span></span>).outV().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">ov</span><span class="delimiter">&quot;</span></span>)).
               where(<span class="string"><span class="delimiter">&quot;</span><span class="content">ie</span><span class="delimiter">&quot;</span></span>,neq(<span class="string"><span class="delimiter">&quot;</span><span class="content">e</span><span class="delimiter">&quot;</span></span>)).
               where(<span class="string"><span class="delimiter">&quot;</span><span class="content">ie</span><span class="delimiter">&quot;</span></span>,eq(<span class="string"><span class="delimiter">&quot;</span><span class="content">e</span><span class="delimiter">&quot;</span></span>)).by(label).
             select(<span class="string"><span class="delimiter">&quot;</span><span class="content">ie</span><span class="delimiter">&quot;</span></span>).
             group().
               by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">ov</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">e</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">iv</span><span class="delimiter">&quot;</span></span>).by().by(label)).
             unfold().select(values).
               where(count(local).is(gt(<span class="integer">1</span>)))
==&gt;[e[<span class="integer">13</span>][<span class="integer">1</span>-created-&gt;<span class="integer">3</span>],e[<span class="integer">9</span>][<span class="integer">1</span>-created-&gt;<span class="integer">3</span>]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>A third way to approach this problem would be to force a <a href="https://en.wikipedia.org/wiki/Depth-first_search">depth-first search</a>.
The previous examples invoke traversal strategies that force a <a href="https://en.wikipedia.org/wiki/Breadth-first_search">breadth first search</a>
as a performance optimization.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.withoutStrategies(LazyBarrierStrategy, PathRetractionStrategy).V().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">ov</span><span class="delimiter">&quot;</span></span>). <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
           outE().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">e1</span><span class="delimiter">&quot;</span></span>).
           inV().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">iv</span><span class="delimiter">&quot;</span></span>).
           inE().
           where(neq(<span class="string"><span class="delimiter">&quot;</span><span class="content">e1</span><span class="delimiter">&quot;</span></span>)).
           where(outV().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">ov</span><span class="delimiter">&quot;</span></span>)).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">e2</span><span class="delimiter">&quot;</span></span>). <span class="invisible">//</span><b class="conum">2</b><span class="invisible">\</span>
           where(<span class="string"><span class="delimiter">&quot;</span><span class="content">e1</span><span class="delimiter">&quot;</span></span>, eq(<span class="string"><span class="delimiter">&quot;</span><span class="content">e2</span><span class="delimiter">&quot;</span></span>)).by(label) <span class="invisible">//</span><b class="conum">3</b><span class="invisible">\</span>
==&gt;e[<span class="integer">13</span>][<span class="integer">1</span>-created-&gt;<span class="integer">3</span>]
==&gt;e[<span class="integer">9</span>][<span class="integer">1</span>-created-&gt;<span class="integer">3</span>]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Remove strategies that will optimize for breadth first searches and thus allow Gremlin to go depth first.</p>
</li>
<li>
<p>To this point, the traversal is very much like the previous one. Review step 2 in the previous example to see the
parallels here.</p>
</li>
<li>
<p>The final <code>where</code> simply looks for edges that match on label, which would then meet the working definition of
"duplicate".</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The basic pattern at play here is to compare the path of the outgoing vertex, its outgoing edge label and the incoming
vertex. This model can obviously be contracted or expanded as needed to fit different definitions of "duplicate". For
example, a "duplicate" definition could extended to the label and properties of the edge. For purposes of
demonstration, an additional edge is added to the "modern" graph:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V(<span class="integer">1</span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).V(<span class="integer">3</span>).addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">created</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">weight</span><span class="delimiter">&quot;</span></span>,<span class="float">0.4d</span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).iterate()
gremlin&gt; g.V(<span class="integer">1</span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).V(<span class="integer">3</span>).addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">created</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">weight</span><span class="delimiter">&quot;</span></span>,<span class="float">0.5d</span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).iterate()
gremlin&gt; g.V(<span class="integer">1</span>).outE(<span class="string"><span class="delimiter">&quot;</span><span class="content">created</span><span class="delimiter">&quot;</span></span>).valueMap(<span class="predefined-constant">true</span>)
==&gt;[<span class="key">id</span>:<span class="integer">9</span>,<span class="key">weight</span>:<span class="float">0.4</span>,<span class="key">label</span>:created]
==&gt;[<span class="key">id</span>:<span class="integer">13</span>,<span class="key">weight</span>:<span class="float">0.4</span>,<span class="key">label</span>:created]
==&gt;[<span class="key">id</span>:<span class="integer">14</span>,<span class="key">weight</span>:<span class="float">0.5</span>,<span class="key">label</span>:created]</code></pre>
</div>
</div>
<div class="paragraph">
<p>To identify the duplicate with this revised definition, the previous traversal can be modified to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.withoutStrategies(LazyBarrierStrategy, PathRetractionStrategy).V().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">ov</span><span class="delimiter">&quot;</span></span>).
           outE().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">e1</span><span class="delimiter">&quot;</span></span>).
           inV().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">iv</span><span class="delimiter">&quot;</span></span>).
           inE().
           where(neq(<span class="string"><span class="delimiter">&quot;</span><span class="content">e1</span><span class="delimiter">&quot;</span></span>)).
           where(outV().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">ov</span><span class="delimiter">&quot;</span></span>)).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">e2</span><span class="delimiter">&quot;</span></span>).
           where(<span class="string"><span class="delimiter">&quot;</span><span class="content">e1</span><span class="delimiter">&quot;</span></span>, eq(<span class="string"><span class="delimiter">&quot;</span><span class="content">e2</span><span class="delimiter">&quot;</span></span>)).by(label).
           where(<span class="string"><span class="delimiter">&quot;</span><span class="content">e1</span><span class="delimiter">&quot;</span></span>, eq(<span class="string"><span class="delimiter">&quot;</span><span class="content">e2</span><span class="delimiter">&quot;</span></span>)).by(<span class="string"><span class="delimiter">&quot;</span><span class="content">weight</span><span class="delimiter">&quot;</span></span>).valueMap(<span class="predefined-constant">true</span>)
==&gt;[<span class="key">id</span>:<span class="integer">13</span>,<span class="key">weight</span>:<span class="float">0.4</span>,<span class="key">label</span>:created]
==&gt;[<span class="key">id</span>:<span class="integer">9</span>,<span class="key">weight</span>:<span class="float">0.4</span>,<span class="key">label</span>:created]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="duplicate-vertex">Duplicate Vertex Detection</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The pattern for finding duplicate vertices is quite similar to the pattern defined in the <a href="#duplicate-edge">Duplicate Edge</a>
section. The idea is to extract the relevant features of the vertex into a comparable list that can then be used to
group for duplicates.</p>
</div>
<div class="paragraph">
<p>Consider the following example with some duplicate vertices added to the "modern" graph:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.addV(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">vadas</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">age</span><span class="delimiter">'</span></span>, <span class="integer">27</span>)
==&gt;v[<span class="integer">13</span>]
gremlin&gt; g.addV(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">vadas</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">age</span><span class="delimiter">'</span></span>, <span class="integer">22</span>) <span class="comment">// not a duplicate because &quot;age&quot; value</span>
==&gt;v[<span class="integer">16</span>]
gremlin&gt; g.addV(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">age</span><span class="delimiter">'</span></span>, <span class="integer">29</span>)
==&gt;v[<span class="integer">19</span>]
gremlin&gt; g.V().hasLabel(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>).
           group().
             by(values(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>).fold()).
           unfold()
==&gt;[marko, <span class="integer">29</span>]=[v[<span class="integer">1</span>], v[<span class="integer">19</span>]]
==&gt;[vadas, <span class="integer">27</span>]=[v[<span class="integer">2</span>], v[<span class="integer">13</span>]]
==&gt;[peter, <span class="integer">35</span>]=[v[<span class="integer">6</span>]]
==&gt;[vadas, <span class="integer">22</span>]=[v[<span class="integer">16</span>]]
==&gt;[josh, <span class="integer">32</span>]=[v[<span class="integer">4</span>]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above case, the "name" and "age" properties are the relevant features for identifying duplication. The key in
the <code>Map</code> provided by the <code>group</code> is the list of features for comparison and the value is the list of vertices that
match the feature. To extract just those vertices that contain duplicates an additional filter can be added:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().hasLabel(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>).
           group().
             by(values(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>).fold()).
           unfold().
           filter(select(values).count(local).is(gt(<span class="integer">1</span>)))
==&gt;[marko, <span class="integer">29</span>]=[v[<span class="integer">1</span>], v[<span class="integer">19</span>]]
==&gt;[vadas, <span class="integer">27</span>]=[v[<span class="integer">2</span>], v[<span class="integer">13</span>]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>That filter, extracts the values of the <code>Map</code> and counts the vertices within each list. If that list contains more than
one vertex then it is a duplicate.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="if-then-based-grouping">If-Then Based Grouping</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Consider the following traversal over the "modern" toy graph:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().hasLabel(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>).groupCount().by(<span class="string"><span class="delimiter">'</span><span class="content">age</span><span class="delimiter">'</span></span>)
==&gt;[<span class="integer">32</span>:<span class="integer">1</span>,<span class="integer">35</span>:<span class="integer">1</span>,<span class="integer">27</span>:<span class="integer">1</span>,<span class="integer">29</span>:<span class="integer">1</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result is an age distribution that simply shows that every "person" in the graph is of a different age. In some
cases, this result is exactly what is needed, but sometimes a grouping may need to be transformed to provide a
different picture of the result. For example, perhaps a grouping on the value "age" would be better represented by
a domain concept such as "young", "old" and "very old".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().hasLabel(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>).groupCount().by(values(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>).choose(
           is(lt(<span class="integer">28</span>)),constant(<span class="string"><span class="delimiter">&quot;</span><span class="content">young</span><span class="delimiter">&quot;</span></span>),
           choose(is(lt(<span class="integer">30</span>)),
                  constant(<span class="string"><span class="delimiter">&quot;</span><span class="content">old</span><span class="delimiter">&quot;</span></span>),
                  constant(<span class="string"><span class="delimiter">&quot;</span><span class="content">very old</span><span class="delimiter">&quot;</span></span>))))
==&gt;[<span class="key">young</span>:<span class="integer">1</span>,<span class="key">old</span>:<span class="integer">1</span>,very <span class="key">old</span>:<span class="integer">2</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the <code>by</code> modulator has been altered from simply taking a string key of "age" to take a <code>Traversal</code>. That
inner <code>Traversal</code> utilizes <code>choose</code> which is like an <code>if-then-else</code> clause. The <code>choose</code> is nested and would look
like the following in Java:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">if</span> (age &lt; <span class="integer">28</span>) {
  <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">young</span><span class="delimiter">&quot;</span></span>;
} <span class="keyword">else</span> {
  <span class="keyword">if</span> (age &lt; <span class="integer">30</span>) {
    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">old</span><span class="delimiter">&quot;</span></span>;
  } <span class="keyword">else</span> {
    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">very old</span><span class="delimiter">&quot;</span></span>;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The use of <code>choose</code> is a good intuitive choice for this <code>Traversal</code> as it is a natural mapping to <code>if-then-else</code>, but
there is another option to consider with <code>coalesce</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().hasLabel(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>).
           groupCount().by(values(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>).
           coalesce(is(lt(<span class="integer">28</span>)).constant(<span class="string"><span class="delimiter">&quot;</span><span class="content">young</span><span class="delimiter">&quot;</span></span>),
                    is(lt(<span class="integer">30</span>)).constant(<span class="string"><span class="delimiter">&quot;</span><span class="content">old</span><span class="delimiter">&quot;</span></span>),
                    constant(<span class="string"><span class="delimiter">&quot;</span><span class="content">very old</span><span class="delimiter">&quot;</span></span>)))
==&gt;[<span class="key">young</span>:<span class="integer">1</span>,<span class="key">old</span>:<span class="integer">1</span>,very <span class="key">old</span>:<span class="integer">2</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The answer is the same, but this traversal removes the nested <code>choose</code>, which makes it easier to read.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pagination">Pagination</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="image" style="float: left"><img src="../images/gremlin-paging.png" alt="gremlin paging" width="330"></span>In most database applications, it is oftentimes desirable to return
discrete blocks of data for a query rather than all of the data that the total results would contain. This approach to
returning data is referred to as "pagination" and typically involves a situation where the client executing the query
can specify the start position and end position (or the amount of data to return in lieu of the end position)
representing the block of data to return. In this way, one could return the first ten records of one hundred, then the
second ten records and so on, until potentially all one hundred were returned.</p>
</div>
<div class="paragraph">
<p>In Gremlin, a basic approach to paging would look something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().hasLabel(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>).fold() <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
==&gt;[v[<span class="integer">1</span>],v[<span class="integer">2</span>],v[<span class="integer">4</span>],v[<span class="integer">6</span>]]
gremlin&gt; g.V().hasLabel(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>).
           fold().as(<span class="string"><span class="delimiter">'</span><span class="content">persons</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">count</span><span class="delimiter">'</span></span>).
           select(<span class="string"><span class="delimiter">'</span><span class="content">persons</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">count</span><span class="delimiter">'</span></span>).
             by(range(local, <span class="integer">0</span>, <span class="integer">2</span>)).
             by(count(local)) <span class="invisible">//</span><b class="conum">2</b><span class="invisible">\</span>
==&gt;[<span class="key">persons</span>:[v[<span class="integer">1</span>],v[<span class="integer">2</span>]],<span class="key">count</span>:<span class="integer">4</span>]
gremlin&gt; g.V().hasLabel(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>).
           fold().as(<span class="string"><span class="delimiter">'</span><span class="content">persons</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">count</span><span class="delimiter">'</span></span>).
           select(<span class="string"><span class="delimiter">'</span><span class="content">persons</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">count</span><span class="delimiter">'</span></span>).
             by(range(local, <span class="integer">2</span>, <span class="integer">4</span>)).
             by(count(local)) <span class="invisible">//</span><b class="conum">3</b><span class="invisible">\</span>
==&gt;[<span class="key">persons</span>:[v[<span class="integer">4</span>],v[<span class="integer">6</span>]],<span class="key">count</span>:<span class="integer">4</span>]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Gets all the "person" vertices.</p>
</li>
<li>
<p>Gets the first two "person" vertices and includes the total number of vertices so that the client knows how many
it has to page through.</p>
</li>
<li>
<p>Gets the final two "person" vertices.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>From a functional perspective, the above example shows a fairly standard paging model. Unfortunately, there is a
problem. To get the total number of vertices, the traversal must first <code>fold()</code> them, which iterates out
the traversal bringing them all into memory. If the number of "person" vertices is large, that step could lead to a
long running traversal and perhaps one that would simply run out of memory prior to completion. There is no shortcut
to getting a total count without doing a full iteration of the traversal. If the requirement for a total count is
removed then the traversals become more simple:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().hasLabel(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>).range(<span class="integer">0</span>,<span class="integer">2</span>)
==&gt;v[<span class="integer">1</span>]
==&gt;v[<span class="integer">2</span>]
gremlin&gt; g.V().hasLabel(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>).range(<span class="integer">2</span>,<span class="integer">4</span>)
==&gt;v[<span class="integer">4</span>]
==&gt;v[<span class="integer">6</span>]</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The first traversal above could also be written as <code>g.V().hasLabel('person').limit(2)</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In this case, there is no way to know the total count so the only way to know if the end of the results have been
reached is to count the results from each paged result to see if there&#8217;s less than the number expected or simply zero
results. In that case, further requests for additional pages would be unnecessary. Of course, this approach is not
free of problems either. Most graph databases will not optimize the <code>range()</code> step, meaning that the second traversal
will repeat the iteration of the first two vertices to get to the second set of two vertices. In other words, for the
second traversal, the graph will still read four vertices even though there was only a request for two.</p>
</div>
<div class="paragraph">
<p>The only way to completely avoid that problem is to re-use the same traversal instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; t = g.V().hasLabel(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>);<span class="type">[]</span>
gremlin&gt; t.next(<span class="integer">2</span>)
==&gt;v[<span class="integer">1</span>]
==&gt;v[<span class="integer">2</span>]
gremlin&gt; t.next(<span class="integer">2</span>)
==&gt;v[<span class="integer">4</span>]
==&gt;v[<span class="integer">6</span>]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="recommendation">Recommendation</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="image" style="float: left"><img src="../images/gremlin-recommendation.png" alt="gremlin recommendation" width="180"></span>One of the more common use cases for a graph database is the
development of <a href="https://en.wikipedia.org/wiki/Recommender_system">recommendation systems</a> and a simple approach to
doing that is through <a href="https://en.wikipedia.org/wiki/Collaborative_filtering">collaborative filtering</a>.
Collaborative filtering assumes that if a person shares one set of opinions with a different person, they are likely to
have similar taste with respect to other issues. With that basis in mind, it is then possible to make predictions for a
specific person as to what their opinions might be.</p>
</div>
<div class="paragraph">
<p>As a simple example, consider a graph that contains "person" and "product" vertices connected by "bought" edges. The
following script generates some data for the graph using that basic schema:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">bob</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">jon</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">jack</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">jill</span><span class="delimiter">&quot;</span></span>)iterate()
gremlin&gt; (<span class="integer">1</span>..<span class="integer">10</span>).each {
           g.addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">product</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">product #</span><span class="inline"><span class="inline-delimiter">${</span><span class="local-variable">it</span><span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>).iterate()
         }; <span class="type">[]</span>
gremlin&gt; (<span class="integer">3</span>..<span class="integer">7</span>).each {
           g.V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">p</span><span class="delimiter">&quot;</span></span>).
             V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">product</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">product #</span><span class="inline"><span class="inline-delimiter">${</span><span class="local-variable">it</span><span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>).addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">p</span><span class="delimiter">&quot;</span></span>).iterate()
         }; <span class="type">[]</span>
gremlin&gt; (<span class="integer">1</span>..<span class="integer">5</span>).each {
           g.V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">bob</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">p</span><span class="delimiter">&quot;</span></span>).
             V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">product</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">product #</span><span class="inline"><span class="inline-delimiter">${</span><span class="local-variable">it</span><span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>).addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">p</span><span class="delimiter">&quot;</span></span>).iterate()
         }; <span class="type">[]</span>
gremlin&gt; (<span class="integer">6</span>..<span class="integer">10</span>).each {
           g.V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">jon</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">p</span><span class="delimiter">&quot;</span></span>).
             V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">product</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">product #</span><span class="inline"><span class="inline-delimiter">${</span><span class="local-variable">it</span><span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>).addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">p</span><span class="delimiter">&quot;</span></span>).iterate()
         }; <span class="type">[]</span>
gremlin&gt; <span class="integer">1</span>.step(<span class="integer">10</span>, <span class="integer">2</span>) {
           g.V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">jack</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">p</span><span class="delimiter">&quot;</span></span>).
             V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">product</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">product #</span><span class="inline"><span class="inline-delimiter">${</span><span class="local-variable">it</span><span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>).addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">p</span><span class="delimiter">&quot;</span></span>).iterate()
         }; <span class="type">[]</span>
gremlin&gt; <span class="integer">2</span>.step(<span class="integer">10</span>, <span class="integer">2</span>) {
           g.V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">jill</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">p</span><span class="delimiter">&quot;</span></span>).
             V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">product</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">product #</span><span class="inline"><span class="inline-delimiter">${</span><span class="local-variable">it</span><span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>).addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">p</span><span class="delimiter">&quot;</span></span>).iterate()
         }; <span class="type">[]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The first step to making a recommendation to "alice" using collaborative filtering is to understand what she bought:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">alice</span><span class="delimiter">'</span></span>).out(<span class="string"><span class="delimiter">'</span><span class="content">bought</span><span class="delimiter">'</span></span>).values(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>)
==&gt;product <span class="error">#</span><span class="integer">5</span>
==&gt;product <span class="error">#</span><span class="integer">6</span>
==&gt;product <span class="error">#</span><span class="integer">7</span>
==&gt;product <span class="error">#</span><span class="integer">3</span>
==&gt;product <span class="error">#</span><span class="integer">4</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The following diagram depicts one of the edges traversed in the above example between "alice" and "product #5".
Obviously, the other products "alice" bought would have similar relations, but this diagram and those to follow will
focus on the neighborhood around that product.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../images/recommendation-alice-1.png" alt="recommendation alice 1" width="500"></span></p>
</div>
<div class="paragraph">
<p>The next step is to determine who else purchased those products:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">alice</span><span class="delimiter">'</span></span>).out(<span class="string"><span class="delimiter">'</span><span class="content">bought</span><span class="delimiter">'</span></span>).in(<span class="string"><span class="delimiter">'</span><span class="content">bought</span><span class="delimiter">'</span></span>).dedup().values(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>)
==&gt;alice
==&gt;bob
==&gt;jack
==&gt;jill
==&gt;jon</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is worth noting that "alice" is in the results above. She should really be excluded from the list as the
interest is in what individuals other than herself purchased:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">alice</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">her</span><span class="delimiter">'</span></span>).
               out(<span class="string"><span class="delimiter">'</span><span class="content">bought</span><span class="delimiter">'</span></span>).
               in(<span class="string"><span class="delimiter">'</span><span class="content">bought</span><span class="delimiter">'</span></span>).where(neq(<span class="string"><span class="delimiter">'</span><span class="content">her</span><span class="delimiter">'</span></span>)).
               dedup().values(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>)
==&gt;bob
==&gt;jack
==&gt;jill
==&gt;jon</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following diagram shows "alice" and those others who purchased "product #5".</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../images/recommendation-alice-2.png" alt="recommendation alice 2" width="600"></span></p>
</div>
<div class="paragraph">
<p>The knowledge of the people who bought the same things as "alice" can then be used to find the set of products that
they bought:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">alice</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">her</span><span class="delimiter">'</span></span>).
               out(<span class="string"><span class="delimiter">'</span><span class="content">bought</span><span class="delimiter">'</span></span>).
               in(<span class="string"><span class="delimiter">'</span><span class="content">bought</span><span class="delimiter">'</span></span>).where(neq(<span class="string"><span class="delimiter">'</span><span class="content">her</span><span class="delimiter">'</span></span>)).
               out(<span class="string"><span class="delimiter">'</span><span class="content">bought</span><span class="delimiter">'</span></span>).
               dedup().values(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>)
==&gt;product <span class="error">#</span><span class="integer">1</span>
==&gt;product <span class="error">#</span><span class="integer">2</span>
==&gt;product <span class="error">#</span><span class="integer">3</span>
==&gt;product <span class="error">#</span><span class="integer">4</span>
==&gt;product <span class="error">#</span><span class="integer">5</span>
==&gt;product <span class="error">#</span><span class="integer">7</span>
==&gt;product <span class="error">#</span><span class="integer">9</span>
==&gt;product <span class="error">#</span><span class="integer">6</span>
==&gt;product <span class="error">#</span><span class="integer">8</span>
==&gt;product <span class="error">#</span><span class="integer">10</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="../images/recommendation-alice-3.png" alt="recommendation alice 3" width="800"></span></p>
</div>
<div class="paragraph">
<p>This set of products could be the basis for recommendation, but it is important to remember that "alice" may have
already purchased some of these products and it would be better to not pester her with recommendations for products
that she already owns. Those products she already purchased can be excluded as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">alice</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">her</span><span class="delimiter">'</span></span>).
               out(<span class="string"><span class="delimiter">'</span><span class="content">bought</span><span class="delimiter">'</span></span>).aggregate(<span class="string"><span class="delimiter">'</span><span class="content">self</span><span class="delimiter">'</span></span>).
               in(<span class="string"><span class="delimiter">'</span><span class="content">bought</span><span class="delimiter">'</span></span>).where(neq(<span class="string"><span class="delimiter">'</span><span class="content">her</span><span class="delimiter">'</span></span>)).
               out(<span class="string"><span class="delimiter">'</span><span class="content">bought</span><span class="delimiter">'</span></span>).where(without(<span class="string"><span class="delimiter">'</span><span class="content">self</span><span class="delimiter">'</span></span>)).
               dedup().values(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>)
==&gt;product <span class="error">#</span><span class="integer">1</span>
==&gt;product <span class="error">#</span><span class="integer">2</span>
==&gt;product <span class="error">#</span><span class="integer">9</span>
==&gt;product <span class="error">#</span><span class="integer">8</span>
==&gt;product <span class="error">#</span><span class="integer">10</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="../images/recommendation-alice-4.png" alt="recommendation alice 4" width="800"></span></p>
</div>
<div class="paragraph">
<p>The final step would be to group the remaining products (instead of <code>dedup()</code> which was mostly done for demonstration
purposes) to form a ranking:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">alice</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">her</span><span class="delimiter">'</span></span>). <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
               out(<span class="string"><span class="delimiter">'</span><span class="content">bought</span><span class="delimiter">'</span></span>).aggregate(<span class="string"><span class="delimiter">'</span><span class="content">self</span><span class="delimiter">'</span></span>). <span class="invisible">//</span><b class="conum">2</b><span class="invisible">\</span>
               <span class="keyword">in</span>(<span class="string"><span class="delimiter">'</span><span class="content">bought</span><span class="delimiter">'</span></span>).where(neq(<span class="string"><span class="delimiter">'</span><span class="content">her</span><span class="delimiter">'</span></span>)). <span class="invisible">//</span><b class="conum">3</b><span class="invisible">\</span>
               out(<span class="string"><span class="delimiter">'</span><span class="content">bought</span><span class="delimiter">'</span></span>).where(without(<span class="string"><span class="delimiter">'</span><span class="content">self</span><span class="delimiter">'</span></span>)). <span class="invisible">//</span><b class="conum">4</b><span class="invisible">\</span>
               groupCount().
               order(local).
                 by(values, decr) <span class="invisible">//</span><b class="conum">5</b><span class="invisible">\</span>
==&gt;[v[<span class="integer">10</span>]:<span class="integer">6</span>,v[<span class="integer">26</span>]:<span class="integer">5</span>,v[<span class="integer">12</span>]:<span class="integer">5</span>,v[<span class="integer">24</span>]:<span class="integer">4</span>,v[<span class="integer">28</span>]:<span class="integer">2</span>]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Find "alice" who is the person for whom the product recommendation is being made.</p>
</li>
<li>
<p>Traverse to the products that "alice" bought and gather them for later use in the traversal.</p>
</li>
<li>
<p>Traverse to the "person" vertices who bought the products that "alice" bought and exclude "alice" herself from that list.</p>
</li>
<li>
<p>Given those people who bought similar products to "alice", find the products that they bought and exclude those that she already bought.</p>
</li>
<li>
<p>Group the products and count the number of times they were purchased by others to come up with a ranking of products to recommend to "alice".</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The previous example was already described as "basic" and obviously could take into account whatever data is available
to further improve the quality of the recommendation (e.g. product ratings, times of purchase, etc.).  One option to
improve the quality of what is recommended (without expanding the previous dataset) might be to choose the person
vertices that make up the recommendation to "alice" who have the largest common set of purchases.</p>
</div>
<div class="paragraph">
<p>Looking back to the previous code example, consider its more strip down representation that shows those individuals
who have at least one product in common:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>).
               out(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).aggregate(<span class="string"><span class="delimiter">&quot;</span><span class="content">self</span><span class="delimiter">&quot;</span></span>).
               in(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).where(neq(<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>)).dedup()
==&gt;v[<span class="integer">2</span>]
==&gt;v[<span class="integer">6</span>]
==&gt;v[<span class="integer">8</span>]
==&gt;v[<span class="integer">4</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, do some grouping to find count how many products they have in common:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>).
               out(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).aggregate(<span class="string"><span class="delimiter">&quot;</span><span class="content">self</span><span class="delimiter">&quot;</span></span>).
               in(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).where(neq(<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>)).dedup().
               group().
                 by().by(out(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).
               where(within(<span class="string"><span class="delimiter">&quot;</span><span class="content">self</span><span class="delimiter">&quot;</span></span>)).count())
==&gt;[v[<span class="integer">2</span>]:<span class="integer">3</span>,v[<span class="integer">4</span>]:<span class="integer">2</span>,v[<span class="integer">6</span>]:<span class="integer">3</span>,v[<span class="integer">8</span>]:<span class="integer">2</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above output shows that the best that can be expected is three common products. The traversal needs to be aware of
that maximum:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>).
               out(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).aggregate(<span class="string"><span class="delimiter">&quot;</span><span class="content">self</span><span class="delimiter">&quot;</span></span>).
               in(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).where(neq(<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>)).dedup().
               group().
                 by().by(out(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).
               where(within(<span class="string"><span class="delimiter">&quot;</span><span class="content">self</span><span class="delimiter">&quot;</span></span>)).count()).
               select(values).
               order(local).
                 by(decr).limit(local, <span class="integer">1</span>)
==&gt;<span class="integer">3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>With the maximum value available, it can be used to chose those "person" vertices that have the three products in
common:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>).
               out(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).aggregate(<span class="string"><span class="delimiter">&quot;</span><span class="content">self</span><span class="delimiter">&quot;</span></span>).
               in(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).where(neq(<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>)).dedup().
               group().
                 by().by(out(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).
               where(within(<span class="string"><span class="delimiter">&quot;</span><span class="content">self</span><span class="delimiter">&quot;</span></span>)).count()).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">g</span><span class="delimiter">&quot;</span></span>).
               select(values).
               order(local).
                 by(decr).limit(local, <span class="integer">1</span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">m</span><span class="delimiter">&quot;</span></span>).
               select(<span class="string"><span class="delimiter">&quot;</span><span class="content">g</span><span class="delimiter">&quot;</span></span>).unfold().
               where(select(values).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">m</span><span class="delimiter">&quot;</span></span>)).select(keys)
==&gt;v[<span class="integer">2</span>]
==&gt;v[<span class="integer">6</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that there is a list of "person" vertices to base the recommendation on, traverse to the products that they
purchased:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>).
               out(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).aggregate(<span class="string"><span class="delimiter">&quot;</span><span class="content">self</span><span class="delimiter">&quot;</span></span>).
               in(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).where(neq(<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>)).dedup().
               group().
                 by().by(out(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).
               where(within(<span class="string"><span class="delimiter">&quot;</span><span class="content">self</span><span class="delimiter">&quot;</span></span>)).count()).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">g</span><span class="delimiter">&quot;</span></span>).
               select(values).
               order(local).
                 by(decr).limit(local, <span class="integer">1</span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">m</span><span class="delimiter">&quot;</span></span>).
               select(<span class="string"><span class="delimiter">&quot;</span><span class="content">g</span><span class="delimiter">&quot;</span></span>).unfold().
               where(select(values).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">m</span><span class="delimiter">&quot;</span></span>)).select(keys).
               out(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).where(without(<span class="string"><span class="delimiter">&quot;</span><span class="content">self</span><span class="delimiter">&quot;</span></span>))
==&gt;v[<span class="integer">10</span>]
==&gt;v[<span class="integer">12</span>]
==&gt;v[<span class="integer">26</span>]
==&gt;v[<span class="integer">10</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above output shows that one product is held in common making it the top recommendation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>).
               out(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).aggregate(<span class="string"><span class="delimiter">&quot;</span><span class="content">self</span><span class="delimiter">&quot;</span></span>).
               in(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).where(neq(<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>)).dedup().
               group().
                 by().by(out(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).
               where(within(<span class="string"><span class="delimiter">&quot;</span><span class="content">self</span><span class="delimiter">&quot;</span></span>)).count()).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">g</span><span class="delimiter">&quot;</span></span>).
               select(values).
               order(local).
                 by(decr).limit(local, <span class="integer">1</span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">m</span><span class="delimiter">&quot;</span></span>).
               select(<span class="string"><span class="delimiter">&quot;</span><span class="content">g</span><span class="delimiter">&quot;</span></span>).unfold().
               where(select(values).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">m</span><span class="delimiter">&quot;</span></span>)).select(keys).
               out(<span class="string"><span class="delimiter">&quot;</span><span class="content">bought</span><span class="delimiter">&quot;</span></span>).where(without(<span class="string"><span class="delimiter">&quot;</span><span class="content">self</span><span class="delimiter">&quot;</span></span>)).
               groupCount().
               order(local).
                 by(values, decr).
                 by(select(keys).values(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>)).
               unfold().select(keys).values(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>)
==&gt;product <span class="error">#</span><span class="integer">1</span>
==&gt;product <span class="error">#</span><span class="integer">2</span>
==&gt;product <span class="error">#</span><span class="integer">9</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In considering the practical applications of this recipe, it is worth revisiting the earlier "basic" version of the
recommendation algorithm:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">alice</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">her</span><span class="delimiter">'</span></span>).
               out(<span class="string"><span class="delimiter">'</span><span class="content">bought</span><span class="delimiter">'</span></span>).aggregate(<span class="string"><span class="delimiter">'</span><span class="content">self</span><span class="delimiter">'</span></span>).
               in(<span class="string"><span class="delimiter">'</span><span class="content">bought</span><span class="delimiter">'</span></span>).where(neq(<span class="string"><span class="delimiter">'</span><span class="content">her</span><span class="delimiter">'</span></span>)).
               out(<span class="string"><span class="delimiter">'</span><span class="content">bought</span><span class="delimiter">'</span></span>).where(without(<span class="string"><span class="delimiter">'</span><span class="content">self</span><span class="delimiter">'</span></span>)).
               groupCount().
               order(local).
                 by(values, decr)
==&gt;[v[<span class="integer">10</span>]:<span class="integer">6</span>,v[<span class="integer">26</span>]:<span class="integer">5</span>,v[<span class="integer">12</span>]:<span class="integer">5</span>,v[<span class="integer">24</span>]:<span class="integer">4</span>,v[<span class="integer">28</span>]:<span class="integer">2</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above traversal performs a full ranking of items based on all the connected data. That could be a time consuming
operation depending on the number of paths being traversed. As it turns out, recommendations don&#8217;t need to have perfect
knowledge of all data to provide a "pretty good" approximation of a recommendation. It can therefore make sense to
place additional limits on the traversal to have it better return more quickly at the expense of examining less data.</p>
</div>
<div class="paragraph">
<p>Gremlin provides a number of steps that can help with these limits like:
<a href="http://tinkerpop.apache.org/docs/3.3.1/reference/#coin-step">coin()</a>,
<a href="http://tinkerpop.apache.org/docs/3.3.1/reference/#sample-step">sample()</a>, and
<a href="http://tinkerpop.apache.org/docs/current/reference/#timelimit-step">timeLimit()</a>. For example, to have the
traversal sample the data for no longer than one second, the previous "basic" recommendation could be changed to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">alice</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">her</span><span class="delimiter">'</span></span>).
               out(<span class="string"><span class="delimiter">'</span><span class="content">bought</span><span class="delimiter">'</span></span>).aggregate(<span class="string"><span class="delimiter">'</span><span class="content">self</span><span class="delimiter">'</span></span>).
               in(<span class="string"><span class="delimiter">'</span><span class="content">bought</span><span class="delimiter">'</span></span>).where(neq(<span class="string"><span class="delimiter">'</span><span class="content">her</span><span class="delimiter">'</span></span>)).
               out(<span class="string"><span class="delimiter">'</span><span class="content">bought</span><span class="delimiter">'</span></span>).where(without(<span class="string"><span class="delimiter">'</span><span class="content">self</span><span class="delimiter">'</span></span>)).timeLimit(<span class="integer">1000</span>).
               groupCount().
               order(local).
                 by(values, decr)
==&gt;[v[<span class="integer">10</span>]:<span class="integer">6</span>,v[<span class="integer">26</span>]:<span class="integer">5</span>,v[<span class="integer">12</span>]:<span class="integer">5</span>,v[<span class="integer">24</span>]:<span class="integer">4</span>,v[<span class="integer">28</span>]:<span class="integer">2</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>In using sampling methods, it is important to consider that the natural ordering of edges in the graph may not produce
an ideal sample for the recommendation. For example, if the edges end up being returned oldest first, then the
recommendation will be based on the oldest data, which would not be ideal. As with any traversal, it is important to
understand the nature of the graph being traversed and the behavior of the underlying graph database to properly
achieve the desired outcome.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="shortest-path">Shortest Path</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="image"><img src="../images/shortest-path.png" alt="shortest path" width="300"></span></p>
</div>
<div class="paragraph">
<p>When working with a graph, it is often necessary to identify the
<a href="https://en.wikipedia.org/wiki/Shortest_path_problem">shortest path</a> between two identified vertices. The following
is a simple example that identifies the shortest path between vertex "1" and vertex "5" while traversing over out edges:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.addV().property(id, <span class="integer">1</span>).as(<span class="string"><span class="delimiter">'</span><span class="content">1</span><span class="delimiter">'</span></span>).
           addV().property(id, <span class="integer">2</span>).as(<span class="string"><span class="delimiter">'</span><span class="content">2</span><span class="delimiter">'</span></span>).
           addV().property(id, <span class="integer">3</span>).as(<span class="string"><span class="delimiter">'</span><span class="content">3</span><span class="delimiter">'</span></span>).
           addV().property(id, <span class="integer">4</span>).as(<span class="string"><span class="delimiter">'</span><span class="content">4</span><span class="delimiter">'</span></span>).
           addV().property(id, <span class="integer">5</span>).as(<span class="string"><span class="delimiter">'</span><span class="content">5</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">1</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">2</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">2</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">4</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">4</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">5</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">2</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">3</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">3</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">4</span><span class="delimiter">'</span></span>).iterate()
gremlin&gt; g.V(<span class="integer">1</span>).repeat(out().simplePath()).until(hasId(<span class="integer">5</span>)).path().limit(<span class="integer">1</span>) <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
==&gt;[v[<span class="integer">1</span>],v[<span class="integer">2</span>],v[<span class="integer">4</span>],v[<span class="integer">5</span>]]
gremlin&gt; g.V(<span class="integer">1</span>).repeat(out().simplePath()).until(hasId(<span class="integer">5</span>)).path().count(local) <span class="invisible">//</span><b class="conum">2</b><span class="invisible">\</span>
==&gt;<span class="integer">4</span>
==&gt;<span class="integer">5</span>
gremlin&gt; g.V(<span class="integer">1</span>).repeat(out().simplePath()).until(hasId(<span class="integer">5</span>)).path().
           group().by(count(local)).next() <span class="invisible">//</span><b class="conum">3</b><span class="invisible">\</span>
==&gt;<span class="integer">4</span>=[[v[<span class="integer">1</span>], v[<span class="integer">2</span>], v[<span class="integer">4</span>], v[<span class="integer">5</span>]]]
==&gt;<span class="integer">5</span>=[[v[<span class="integer">1</span>], v[<span class="integer">2</span>], v[<span class="integer">3</span>], v[<span class="integer">4</span>], v[<span class="integer">5</span>]]]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The traversal starts at vertex with the identifier of "1" and repeatedly traverses on out edges "until" it finds a
vertex with an identifier of "5". The inclusion of <code>simplePath</code> within the <code>repeat</code> is present to filter out repeated
paths. The traversal terminates with <code>limit</code> in this case as the first path returned will be the shortest one. Of
course, it is possible for there to be more than one path in the graph of the same length (i.e. two or more paths of
length three), but this example is not considering that.</p>
</li>
<li>
<p>It might be interesting to know the path lengths for all paths between vertex "1" and "5".</p>
</li>
<li>
<p>Alternatively, one might wish to do a path length distribution over all the paths.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The previous example defines the length of the path by the number of vertices in the path, but the "path" might also
be measured by data within the graph itself. The following example use the same graph structure as the previous example,
but includes a "weight" on the edges, that will be used to help determine the "cost" of a particular path:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.addV().property(id, <span class="integer">1</span>).as(<span class="string"><span class="delimiter">'</span><span class="content">1</span><span class="delimiter">'</span></span>).
           addV().property(id, <span class="integer">2</span>).as(<span class="string"><span class="delimiter">'</span><span class="content">2</span><span class="delimiter">'</span></span>).
           addV().property(id, <span class="integer">3</span>).as(<span class="string"><span class="delimiter">'</span><span class="content">3</span><span class="delimiter">'</span></span>).
           addV().property(id, <span class="integer">4</span>).as(<span class="string"><span class="delimiter">'</span><span class="content">4</span><span class="delimiter">'</span></span>).
           addV().property(id, <span class="integer">5</span>).as(<span class="string"><span class="delimiter">'</span><span class="content">5</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">1</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">2</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">weight</span><span class="delimiter">'</span></span>, <span class="float">1.25</span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">2</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">4</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">weight</span><span class="delimiter">'</span></span>, <span class="float">1.5</span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">4</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">5</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">weight</span><span class="delimiter">'</span></span>, <span class="float">0.25</span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">2</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">3</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">weight</span><span class="delimiter">'</span></span>, <span class="float">0.25</span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">3</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">4</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">weight</span><span class="delimiter">'</span></span>, <span class="float">0.25</span>).iterate()
gremlin&gt; g.V(<span class="integer">1</span>).repeat(out().simplePath()).until(hasId(<span class="integer">5</span>)).path().
           group().by(count(local)).next() <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
==&gt;<span class="integer">4</span>=[[v[<span class="integer">1</span>], v[<span class="integer">2</span>], v[<span class="integer">4</span>], v[<span class="integer">5</span>]]]
==&gt;<span class="integer">5</span>=[[v[<span class="integer">1</span>], v[<span class="integer">2</span>], v[<span class="integer">3</span>], v[<span class="integer">4</span>], v[<span class="integer">5</span>]]]
gremlin&gt; g.V(<span class="integer">1</span>).repeat(outE().inV().simplePath()).until(hasId(<span class="integer">5</span>)).
           path().by(coalesce(values(<span class="string"><span class="delimiter">'</span><span class="content">weight</span><span class="delimiter">'</span></span>),
                              constant(<span class="float">0.0</span>))).
           map(unfold().sum()) <span class="invisible">//</span><b class="conum">2</b><span class="invisible">\</span>
==&gt;<span class="float">3.00</span>
==&gt;<span class="float">2.00</span>
gremlin&gt; g.V(<span class="integer">1</span>).repeat(outE().inV().simplePath()).until(hasId(<span class="integer">5</span>)).
           path().by(constant(<span class="float">0.0</span>)).by(<span class="string"><span class="delimiter">'</span><span class="content">weight</span><span class="delimiter">'</span></span>).map(unfold().sum()) <span class="invisible">//</span><b class="conum">3</b><span class="invisible">\</span>
==&gt;<span class="float">3.00</span>
==&gt;<span class="float">2.00</span>
gremlin&gt; g.V(<span class="integer">1</span>).repeat(outE().inV().simplePath()).until(hasId(<span class="integer">5</span>)).
           path().as(<span class="string"><span class="delimiter">'</span><span class="content">p</span><span class="delimiter">'</span></span>).
           map(unfold().coalesce(values(<span class="string"><span class="delimiter">'</span><span class="content">weight</span><span class="delimiter">'</span></span>),
                                 constant(<span class="float">0.0</span>)).sum()).as(<span class="string"><span class="delimiter">'</span><span class="content">cost</span><span class="delimiter">'</span></span>).
           select(<span class="string"><span class="delimiter">'</span><span class="content">cost</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">p</span><span class="delimiter">'</span></span>) <span class="invisible">//</span><b class="conum">4</b><span class="invisible">\</span>
==&gt;[<span class="key">cost</span>:<span class="float">3.00</span>,<span class="key">p</span>:[v[<span class="integer">1</span>],e[<span class="integer">0</span>][<span class="integer">1</span>-knows-&gt;<span class="integer">2</span>],v[<span class="integer">2</span>],e[<span class="integer">1</span>][<span class="integer">2</span>-knows-&gt;<span class="integer">4</span>],v[<span class="integer">4</span>],e[<span class="integer">2</span>][<span class="integer">4</span>-knows-&gt;<span class="integer">5</span>],v[<span class="integer">5</span>]]]
==&gt;[<span class="key">cost</span>:<span class="float">2.00</span>,<span class="key">p</span>:[v[<span class="integer">1</span>],e[<span class="integer">0</span>][<span class="integer">1</span>-knows-&gt;<span class="integer">2</span>],v[<span class="integer">2</span>],e[<span class="integer">3</span>][<span class="integer">2</span>-knows-&gt;<span class="integer">3</span>],v[<span class="integer">3</span>],e[<span class="integer">4</span>][<span class="integer">3</span>-knows-&gt;<span class="integer">4</span>],v[<span class="integer">4</span>],e[<span class="integer">2</span>][<span class="integer">4</span>-knows-&gt;<span class="integer">5</span>],v[<span class="integer">5</span>]]]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Note that the shortest path as determined by the structure of the graph is the same.</p>
</li>
<li>
<p>Calculate the "cost" of the path as determined by the weight on the edges. As the "weight" data is on the edges
between the vertices, it is necessary to change the contents of the <code>repeat</code> step to use <code>outE().inV()</code> so that the
edge is included in the path. The path is then post-processed with a <code>by</code> modulator that extracts the "weight" value.
The traversal uses <code>coalesce</code> as there is a mixture of vertices and edges in the path and the traversal is only
interested in edge elements that can return a "weight" property. The final part of the traversal executes a map
function over each path, unfolding it and summing the weights.</p>
</li>
<li>
<p>The same traversal as the one above it, but avoids the use of <code>coalesce</code> with the use of two <code>by</code> modulators. The
<code>by</code> modulator is applied in a round-robin fashion, so the first <code>by</code> will always apply to a vertex (as it is the first
item in every path) and the second <code>by</code> will always apply to an edge (as it always follows the vertex in the path).</p>
</li>
<li>
<p>The output of the previous examples of the "cost" wasn&#8217;t terribly useful as it didn&#8217;t include which path had the
calculated cost. With some slight modifications given the use of <code>select</code> it becomes possible to include the path in
the output. Note that the path with the lowest "cost" actually has a longer path length as determined by the graph
structure.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="traversal-induced-values">Traversal Induced Values</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The parameters of a <code>Traversal</code> can be known ahead of time as constants or might otherwise be passed in as dynamic
arguments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>).out(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).has(<span class="string"><span class="delimiter">'</span><span class="content">age</span><span class="delimiter">'</span></span>, gt(<span class="integer">29</span>)).values(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>)
==&gt;josh</code></pre>
</div>
</div>
<div class="paragraph">
<p>In plain language, the above Gremlin asks, "What are the names of the people who Marko knows who are over the age of
29?". In this case, "29" is known as a constant to the traversal. Of course, if the question is changed slightly to
instead ask, "What are the names of the people who Marko knows who are older than he is?", the hardcoding of "29" will
no longer suffice. There are multiple ways Gremlin would allow this second question to be answered. The first is
obvious to any programmer - use a variable:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; marko = g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>).next()
==&gt;v[<span class="integer">1</span>]
gremlin&gt; g.V(marko).out(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).has(<span class="string"><span class="delimiter">'</span><span class="content">age</span><span class="delimiter">'</span></span>, gt(marko.value(<span class="string"><span class="delimiter">'</span><span class="content">age</span><span class="delimiter">'</span></span>))).values(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>)
==&gt;josh</code></pre>
</div>
</div>
<div class="paragraph">
<p>The downside to this approach is that it takes two separate traversals to answer the question. Ideally, there should
be a single traversal, that can query "marko" once, determine his <code>age</code> and then use that for the value supplied to
filter the people he knows. In this way the <em>value</em> for the <code>age</code> in the <code>has()</code>-filter is <em>induced</em> from the <code>Traversal</code>
itself.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>). <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
           out(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">friend</span><span class="delimiter">'</span></span>). <span class="invisible">//</span><b class="conum">2</b><span class="invisible">\</span>
             where(<span class="string"><span class="delimiter">'</span><span class="content">friend</span><span class="delimiter">'</span></span>, gt(<span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>)).by(<span class="string"><span class="delimiter">'</span><span class="content">age</span><span class="delimiter">'</span></span>). <span class="invisible">//</span><b class="conum">3</b><span class="invisible">\</span>
           values(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>) <span class="invisible">//</span><b class="conum">4</b><span class="invisible">\</span>
==&gt;josh</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Find the "marko" <code>Vertex</code> and label it as "marko".</p>
</li>
<li>
<p>Traverse out on the "knows" edges to the adjacent <code>Vertex</code> and label it as "friend".</p>
</li>
<li>
<p>Continue to traverser only if Marko&#8217;s current friend is older than him.</p>
</li>
<li>
<p>Get the name of Marko&#8217;s older friend.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As another example of how traversal induced values can be used, consider a scenario where there was a graph that
contained people, their friendship relationships, and the movies that they liked.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../images/traversal-induced-values-3.png" alt="traversal induced values 3" width="600"></span></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">u1</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">jen</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">u2</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">dave</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">u3</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">movie</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">the wild bunch</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">m1</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">movie</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">young guns</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">m2</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">movie</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">unforgiven</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">m3</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">friend</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">u1</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">u2</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">friend</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">u1</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">u3</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">like</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">u2</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">m1</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">like</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">u2</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">m2</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">like</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">u3</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">m2</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">like</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">u3</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">m3</span><span class="delimiter">&quot;</span></span>).iterate()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Getting a list of all the movies that Alice&#8217;s friends like could be done like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">alice</span><span class="delimiter">'</span></span>).out(<span class="string"><span class="delimiter">&quot;</span><span class="content">friend</span><span class="delimiter">&quot;</span></span>).out(<span class="string"><span class="delimiter">&quot;</span><span class="content">like</span><span class="delimiter">&quot;</span></span>).values(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>)
==&gt;the wild bunch
==&gt;young guns
==&gt;young guns
==&gt;unforgiven</code></pre>
</div>
</div>
<div class="paragraph">
<p>but what if there was a need to get a list of movies that <strong>all</strong> her Alice&#8217;s friends liked. In this case, that would
mean filtering out "the wild bunch" and "unforgiven".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>).
           out(<span class="string"><span class="delimiter">&quot;</span><span class="content">friend</span><span class="delimiter">&quot;</span></span>).aggregate(<span class="string"><span class="delimiter">&quot;</span><span class="content">friends</span><span class="delimiter">&quot;</span></span>). <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
           out(<span class="string"><span class="delimiter">&quot;</span><span class="content">like</span><span class="delimiter">&quot;</span></span>).dedup(). <span class="invisible">//</span><b class="conum">2</b><span class="invisible">\</span>
           filter(__.in(<span class="string"><span class="delimiter">&quot;</span><span class="content">like</span><span class="delimiter">&quot;</span></span>).where(within(<span class="string"><span class="delimiter">&quot;</span><span class="content">friends</span><span class="delimiter">&quot;</span></span>)).count().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>). <span class="invisible">//</span><b class="conum">3</b><span class="invisible">\</span>
                     select(<span class="string"><span class="delimiter">&quot;</span><span class="content">friends</span><span class="delimiter">&quot;</span></span>).count(local).where(eq(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>))). <span class="invisible">//</span><b class="conum">4</b><span class="invisible">\</span>
           values(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>)
==&gt;young guns</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Gather Alice&#8217;s list of friends to a list called "friends".</p>
</li>
<li>
<p>Traverse to the unique list of movies that Alice&#8217;s friends like.</p>
</li>
<li>
<p>Remove movies that weren&#8217;t liked by all friends. This starts by taking each movie and traversing back in on the
"like" edges to friends who liked the movie (note the use of <code>where(within("friends"))</code> to limit those likes to only
Alice&#8217;s friends as aggregated in step one) and count them up into "a".</p>
</li>
<li>
<p>Count the aggregated friends and see if the number matches what was stored in "a" which would mean that all friends
like the movie.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Traversal induced values are not just for filtering. They can also be used when writing the values of the properties
of one <code>Vertex</code> to another:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>).
           out(<span class="string"><span class="delimiter">'</span><span class="content">created</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">creator</span><span class="delimiter">'</span></span>, select(<span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>).by(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>))
==&gt;v[<span class="integer">3</span>]
gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>).out(<span class="string"><span class="delimiter">'</span><span class="content">created</span><span class="delimiter">'</span></span>).valueMap()
==&gt;[<span class="key">creator</span>:[marko],<span class="key">name</span>:[lop],<span class="key">lang</span>:[java]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>In a more complex example of how this might work, consider a situation where the goal is to propagate a value stored on
a particular vertex through one of more additional connected vertices using some value on the connecting edges to
determine the value to assign. For example, the following graph depicts three "tank" vertices where the edges represent
the direction a particular "tank" should drain and the "factor" by which it should do it:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../images/traversal-induced-values-1.png" alt="traversal induced values 1" width="700"></span></p>
</div>
<div class="paragraph">
<p>If the traversal started at tank "a", then the value of "amount" on that tank would be used to calculate what the value
of tank "b" was by multiplying it by the value of the "factor" property on the edge between vertices "a" and "b". In
this case the amount of tank "b" would then be 50. Following this pattern, when going from tank "b" to tank "c", the
value of the "amount" of tank "c" would be 5.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../images/traversal-induced-values-2.png" alt="traversal induced values 2" width="700"></span></p>
</div>
<div class="paragraph">
<p>Using Gremlin <code>sack()</code>, this kind of operation could be specified as a single traversal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.addV(<span class="string"><span class="delimiter">'</span><span class="content">tank</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">amount</span><span class="delimiter">'</span></span>, <span class="float">100.0</span>).as(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>).
           addV(<span class="string"><span class="delimiter">'</span><span class="content">tank</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">amount</span><span class="delimiter">'</span></span>, <span class="float">0.0</span>).as(<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).
           addV(<span class="string"><span class="delimiter">'</span><span class="content">tank</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">amount</span><span class="delimiter">'</span></span>, <span class="float">0.0</span>).as(<span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">drain</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">factor</span><span class="delimiter">'</span></span>, <span class="float">0.5</span>).from(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">drain</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">factor</span><span class="delimiter">'</span></span>, <span class="float">0.1</span>).from(<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span>).iterate()
gremlin&gt; a = g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>).next()
==&gt;v[<span class="integer">0</span>]
gremlin&gt; g.withSack(a.value(<span class="string"><span class="delimiter">'</span><span class="content">amount</span><span class="delimiter">'</span></span>)).
           V(a).repeat(outE(<span class="string"><span class="delimiter">'</span><span class="content">drain</span><span class="delimiter">'</span></span>).sack(mult).by(<span class="string"><span class="delimiter">'</span><span class="content">factor</span><span class="delimiter">'</span></span>).
                       inV().property(<span class="string"><span class="delimiter">'</span><span class="content">amount</span><span class="delimiter">'</span></span>, sack())).
                until(__.outE(<span class="string"><span class="delimiter">'</span><span class="content">drain</span><span class="delimiter">'</span></span>).count().is(<span class="integer">0</span>)).iterate()
gremlin&gt; g.V().valueMap()
==&gt;[<span class="key">amount</span>:[<span class="float">100.0</span>],<span class="key">name</span>:[a]]
==&gt;[<span class="key">amount</span>:[<span class="float">50.00</span>],<span class="key">name</span>:[b]]
==&gt;[<span class="key">amount</span>:[<span class="float">5.000</span>],<span class="key">name</span>:[c]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The "sack value" gets initialized to the value of tank "a". The traversal iteratively traverses out on the "drain"
edges and uses <code>mult</code> to multiply the sack value by the value of "factor". The sack value at that point is then
written to the "amount" of the current vertex.</p>
</div>
<div class="paragraph">
<p>As shown in the previous example, <code>sack()</code> is a useful way to "carry" and manipulate a value that can be later used
elsewhere in the traversal. Here is another example of its usage where it is utilized to increment all the "age" values
in the modern toy graph by 10:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.withSack(<span class="integer">0</span>).V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>).
           sack(assign).by(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>).sack(sum).by(constant(<span class="integer">10</span>)).
           property(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>, sack()).valueMap()
==&gt;[<span class="key">name</span>:[marko],<span class="key">age</span>:[<span class="integer">39</span>]]
==&gt;[<span class="key">name</span>:[vadas],<span class="key">age</span>:[<span class="integer">37</span>]]
==&gt;[<span class="key">name</span>:[josh],<span class="key">age</span>:[<span class="integer">42</span>]]
==&gt;[<span class="key">name</span>:[peter],<span class="key">age</span>:[<span class="integer">45</span>]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above case, the sack is initialized to zero and as each vertex is iterated, the "age" is assigned to the sack
with <code>sack(assign).by('age')</code>. That value in the sack is then incremented by the value <code>constant(10)</code> and assigned to
the "age" property of the same vertex.</p>
</div>
<div class="paragraph">
<p>This value the sack is incremented by need not be a constant. It could also be derived from the traversal itself.
Using the same example, the "weight" property on the incident edges will be used as the value to add to the sack:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.withSack(<span class="integer">0</span>).V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>).
           sack(assign).by(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>).sack(sum).by(bothE().values(<span class="string"><span class="delimiter">&quot;</span><span class="content">weight</span><span class="delimiter">&quot;</span></span>).sum()).
           property(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>, sack()).valueMap()
==&gt;[<span class="key">name</span>:[marko],<span class="key">age</span>:[<span class="float">30.9</span>]]
==&gt;[<span class="key">name</span>:[vadas],<span class="key">age</span>:[<span class="float">27.5</span>]]
==&gt;[<span class="key">name</span>:[josh],<span class="key">age</span>:[<span class="float">34.4</span>]]
==&gt;[<span class="key">name</span>:[peter],<span class="key">age</span>:[<span class="float">35.2</span>]]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tree">Tree</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="image"><img src="../images/gremlin-tree.png" alt="gremlin tree" width="280"></span></p>
</div>
<div class="sect2">
<h3 id="_lowest_common_ancestor">Lowest Common Ancestor</h3>
<div class="paragraph">
<p><span class="image" style="float: right"><img src="../images/tree-lca.png" alt="tree lca" width="230"></span> Given a tree, the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">lowest common ancestor</a>
is the deepest vertex that is common to two or more other vertices. The diagram to the right depicts the common
ancestor tree for vertices A and D in the various green shades. The C vertex, the vertex with the darkest green
shading, is the lowest common ancestor.</p>
</div>
<div class="paragraph">
<p>The following code simply sets up the graph depicted above using "hasParent" for the edge label:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.addV().property(id, <span class="string"><span class="delimiter">'</span><span class="content">A</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>).
           addV().property(id, <span class="string"><span class="delimiter">'</span><span class="content">B</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).
           addV().property(id, <span class="string"><span class="delimiter">'</span><span class="content">C</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span>).
           addV().property(id, <span class="string"><span class="delimiter">'</span><span class="content">D</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">d</span><span class="delimiter">'</span></span>).
           addV().property(id, <span class="string"><span class="delimiter">'</span><span class="content">E</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">e</span><span class="delimiter">'</span></span>).
           addV().property(id, <span class="string"><span class="delimiter">'</span><span class="content">F</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">f</span><span class="delimiter">'</span></span>).
           addV().property(id, <span class="string"><span class="delimiter">'</span><span class="content">G</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">hasParent</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">hasParent</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">hasParent</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">d</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">hasParent</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">e</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">hasParent</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">e</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">f</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">hasParent</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">f</span><span class="delimiter">'</span></span>).iterate()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Given that graph, the following traversal will get the lowest common ancestor for two vertices, A and D:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V(<span class="string"><span class="delimiter">'</span><span class="content">A</span><span class="delimiter">'</span></span>).
           repeat(out(<span class="string"><span class="delimiter">'</span><span class="content">hasParent</span><span class="delimiter">'</span></span>)).emit().as(<span class="string"><span class="delimiter">'</span><span class="content">x</span><span class="delimiter">'</span></span>).
           repeat(__.in(<span class="string"><span class="delimiter">'</span><span class="content">hasParent</span><span class="delimiter">'</span></span>)).emit(hasId(<span class="string"><span class="delimiter">'</span><span class="content">D</span><span class="delimiter">'</span></span>)).
           select(<span class="string"><span class="delimiter">'</span><span class="content">x</span><span class="delimiter">'</span></span>).limit(<span class="integer">1</span>)
==&gt;v[C]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above traversal is reasonably straightforward to follow in that it simply traverses up the tree from the A vertex
and then traverses down from each ancestor until it finds the "D" vertex. The first path that uncovers that match is
the lowest common ancestor.</p>
</div>
<div class="paragraph">
<p>The complexity of finding the lowest common ancestor increases when trying to find the ancestors of three or more
vertices.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; input = [<span class="string"><span class="delimiter">'</span><span class="content">A</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">B</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">D</span><span class="delimiter">'</span></span>]
==&gt;A
==&gt;B
==&gt;D
gremlin&gt; g.V(input.head()).
           repeat(out(<span class="string"><span class="delimiter">'</span><span class="content">hasParent</span><span class="delimiter">'</span></span>)).emit().as(<span class="string"><span class="delimiter">'</span><span class="content">x</span><span class="delimiter">'</span></span>). <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
           V().has(id, within(input.tail())). <span class="invisible">//</span><b class="conum">2</b><span class="invisible">\</span>
           repeat(out(<span class="string"><span class="delimiter">'</span><span class="content">hasParent</span><span class="delimiter">'</span></span>)).emit(where(eq(<span class="string"><span class="delimiter">'</span><span class="content">x</span><span class="delimiter">'</span></span>))). <span class="invisible">//</span><b class="conum">3</b><span class="invisible">\</span>
           group().
             by(select(<span class="string"><span class="delimiter">'</span><span class="content">x</span><span class="delimiter">'</span></span>)).
             by(path().count(local).fold()). <span class="invisible">//</span><b class="conum">4</b><span class="invisible">\</span>
           unfold().filter(select(values).count(local).is(input.tail().size())). <span class="invisible">//</span><b class="conum">5</b><span class="invisible">\</span>
           order().by(select(values).
           unfold().sum()). <span class="invisible">//</span><b class="conum">6</b><span class="invisible">\</span>
           select(keys).limit(<span class="integer">1</span>) <span class="invisible">//</span><b class="conum">7</b><span class="invisible">\</span>
==&gt;v[C]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The start of the traversal is not so different than the previous one and starts with vertex A.</p>
</li>
<li>
<p>Use a mid-traversal <code>V()</code> to find the child vertices B and D.</p>
</li>
<li>
<p>Traverse up the tree for B and D and find common ancestors that were labeled with "x".</p>
</li>
<li>
<p>Group on the common ancestors where the value of the grouping is the length of the path.</p>
</li>
<li>
<p>The result of the previous step is a <code>Map</code> with a vertex (i.e. common ancestor) for the key and a list of path
lengths. Unroll the <code>Map</code> and ensure that the number of path lengths are equivalent to the number of children that
were given to the mid-traversal <code>V()</code>.</p>
</li>
<li>
<p>Order the results based on the sum of the path lengths.</p>
</li>
<li>
<p>Since the results were placed in ascending order, the first result must be the lowest common ancestor.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As the above traversal utilizes a mid-traversal <code>V()</code>, it cannot be used for OLAP. In OLAP, the pattern changes a bit:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.withComputer().
           V().has(id, within(input)).
           aggregate(<span class="string"><span class="delimiter">'</span><span class="content">input</span><span class="delimiter">'</span></span>).hasId(input.head()). <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
           repeat(out(<span class="string"><span class="delimiter">'</span><span class="content">hasParent</span><span class="delimiter">'</span></span>)).emit().as(<span class="string"><span class="delimiter">'</span><span class="content">x</span><span class="delimiter">'</span></span>).
           select(<span class="string"><span class="delimiter">'</span><span class="content">input</span><span class="delimiter">'</span></span>).unfold().has(id, within(input.tail())).
           repeat(out(<span class="string"><span class="delimiter">'</span><span class="content">hasParent</span><span class="delimiter">'</span></span>)).emit(where(eq(<span class="string"><span class="delimiter">'</span><span class="content">x</span><span class="delimiter">'</span></span>))).
           group().
             by(select(<span class="string"><span class="delimiter">'</span><span class="content">x</span><span class="delimiter">'</span></span>)).
             by(path().count(local).fold()).
           unfold().filter(select(values).count(local).is(input.tail().size())).
           order().
             by(select(values).unfold().sum()).
           select(keys).limit(<span class="integer">1</span>)
==&gt;v[C]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The main difference for OLAP is the use of <code>aggregate()</code> over the mid-traversal <code>V()</code>.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_maximum_depth">Maximum Depth</h3>
<div class="paragraph">
<p>Finding the maximum depth of a tree starting from a specified root vertex can be determined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.addV().property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">A</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>).
           addV().property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">B</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).
           addV().property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">C</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span>).
           addV().property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">D</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">d</span><span class="delimiter">'</span></span>).
           addV().property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">E</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">e</span><span class="delimiter">'</span></span>).
           addV().property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">F</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">f</span><span class="delimiter">'</span></span>).
           addV().property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">G</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">hasParent</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">a</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">hasParent</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">b</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">hasParent</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">d</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">hasParent</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">c</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">e</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">hasParent</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">e</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">f</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">hasParent</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">g</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">f</span><span class="delimiter">'</span></span>).iterate()
gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">F</span><span class="delimiter">'</span></span>).repeat(__.in()).emit().path().count(local).max()
==&gt;<span class="integer">5</span>
gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">C</span><span class="delimiter">'</span></span>).repeat(__.in()).emit().path().count(local).max()
==&gt;<span class="integer">3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="image" style="float: right"><img src="../images/gremlin-max-depth.png" alt="gremlin max depth" width="350"></span>The traversals shown above are fairly straightforward. The traversal
beings at a particular starting vertex, traverse in on the "hasParent" edges emitting all vertices as it goes. It
calculates the path length and then selects the longest one. While this approach is quite direct, there is room for
improvement:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">F</span><span class="delimiter">'</span></span>).
           repeat(__.in()).emit(__.not(inE())).tail(<span class="integer">1</span>).
           path().count(local)
==&gt;<span class="integer">5</span>
gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">C</span><span class="delimiter">'</span></span>).
           repeat(__.in()).emit(__.not(inE())).tail(<span class="integer">1</span>).
           path().count(local)
==&gt;<span class="integer">3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are two optimizations at play. First, there is no need to emit all the vertices, only the "leaf" vertices (i.e.
those without incoming edges). Second, all results save the last one can be ignored to that point (i.e. the last one is
the one at the deepest point in the tree). In this way, the path and path length only need to be calculated for a
single result.</p>
</div>
<div class="paragraph">
<p>The previous approaches to calculating the maximum depth use path calculations to achieve the answer. Path calculations
can be expensive and if possible avoided if they are not needed. Another way to express a traversal that calculates
the maximum depth is to use the <code>sack()</code> step:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.withSack(<span class="integer">1</span>).V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">F</span><span class="delimiter">'</span></span>).
           repeat(__.in().sack(sum).by(constant(<span class="integer">1</span>))).emit().
           sack().max()
==&gt;<span class="integer">5</span>
gremlin&gt; g.withSack(<span class="integer">1</span>).V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">C</span><span class="delimiter">'</span></span>).
           repeat(__.in().sack(sum).by(constant(<span class="integer">1</span>))).emit().
           sack().max()
==&gt;<span class="integer">3</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_time_based_indexing">Time-based Indexing</h3>
<div class="paragraph">
<p>Trees can be used for modeling time-oriented data in a graph. Modeling time where there are "year", "month" and "day"
vertices (or lower granularity as needed) allows the structure of the graph to inherently index data tied to them.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../images/gremlin-index-time.png" alt="gremlin index time" width="800"></span></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This model is discussed further in this Neo4j <a href="https://neo4j.com/blog/modeling-a-multilevel-index-in-neoj4/">blog post</a>.
Also, there can be other versions of this model that utilize different edge/vertex labeling and property naming
strategies. The schema depicted here is designed for simplicity.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The Gremlin script below creates the graph depicted in the graph above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.addV(<span class="string"><span class="delimiter">'</span><span class="content">year</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">2016</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">y2016</span><span class="delimiter">'</span></span>).
           addV(<span class="string"><span class="delimiter">'</span><span class="content">month</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">may</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">m05</span><span class="delimiter">'</span></span>).
           addV(<span class="string"><span class="delimiter">'</span><span class="content">month</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">june</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">m06</span><span class="delimiter">'</span></span>).
           addV(<span class="string"><span class="delimiter">'</span><span class="content">day</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">30</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">d30</span><span class="delimiter">'</span></span>).
           addV(<span class="string"><span class="delimiter">'</span><span class="content">day</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">31</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">d31</span><span class="delimiter">'</span></span>).
           addV(<span class="string"><span class="delimiter">'</span><span class="content">day</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">01</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">d01</span><span class="delimiter">'</span></span>).
           addV(<span class="string"><span class="delimiter">'</span><span class="content">event</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">A</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">eA</span><span class="delimiter">'</span></span>).
           addV(<span class="string"><span class="delimiter">'</span><span class="content">event</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">B</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">eB</span><span class="delimiter">'</span></span>).
           addV(<span class="string"><span class="delimiter">'</span><span class="content">event</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">C</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">eC</span><span class="delimiter">'</span></span>).
           addV(<span class="string"><span class="delimiter">'</span><span class="content">event</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">D</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">eD</span><span class="delimiter">'</span></span>).
           addV(<span class="string"><span class="delimiter">'</span><span class="content">event</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">E</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">eE</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">may</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">y2016</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">m05</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">june</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">y2016</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">m06</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">day30</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">m05</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">d30</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">day31</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">m05</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">d31</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">day01</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">m06</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">d01</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">has</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">d30</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">eA</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">has</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">d30</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">eB</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">has</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">d31</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">eC</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">has</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">d31</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">eD</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">has</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">d01</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">eE</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">next</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">d30</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">d31</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">next</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">d31</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">d01</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">next</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">m05</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">m06</span><span class="delimiter">'</span></span>).iterate()</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
The code example above does not create any indices. Proper index creation, which is specific to the
graph implementation used, will be critical to the performance of traversals over this structure.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">2016</span><span class="delimiter">'</span></span>).out().out().out(<span class="string"><span class="delimiter">'</span><span class="content">has</span><span class="delimiter">'</span></span>).values() <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
==&gt;E
==&gt;C
==&gt;D
==&gt;A
==&gt;B
gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">2016</span><span class="delimiter">'</span></span>).out(<span class="string"><span class="delimiter">'</span><span class="content">may</span><span class="delimiter">'</span></span>).out().out(<span class="string"><span class="delimiter">'</span><span class="content">has</span><span class="delimiter">'</span></span>).values() <span class="invisible">//</span><b class="conum">2</b><span class="invisible">\</span>
==&gt;C
==&gt;D
==&gt;A
==&gt;B
gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">2016</span><span class="delimiter">'</span></span>).out(<span class="string"><span class="delimiter">'</span><span class="content">may</span><span class="delimiter">'</span></span>).out(<span class="string"><span class="delimiter">'</span><span class="content">day31</span><span class="delimiter">'</span></span>).out(<span class="string"><span class="delimiter">'</span><span class="content">has</span><span class="delimiter">'</span></span>).values() <span class="invisible">//</span><b class="conum">3</b><span class="invisible">\</span>
==&gt;C
==&gt;D
gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">2016</span><span class="delimiter">'</span></span>).out(<span class="string"><span class="delimiter">'</span><span class="content">may</span><span class="delimiter">'</span></span>).out(<span class="string"><span class="delimiter">'</span><span class="content">day31</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">start</span><span class="delimiter">'</span></span>).
           V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">2016</span><span class="delimiter">'</span></span>).out(<span class="string"><span class="delimiter">'</span><span class="content">june</span><span class="delimiter">'</span></span>).out(<span class="string"><span class="delimiter">'</span><span class="content">day01</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">end</span><span class="delimiter">'</span></span>).
           emit().repeat(__.in(<span class="string"><span class="delimiter">'</span><span class="content">next</span><span class="delimiter">'</span></span>)).until(where(eq(<span class="string"><span class="delimiter">'</span><span class="content">start</span><span class="delimiter">'</span></span>))).
           out(<span class="string"><span class="delimiter">'</span><span class="content">has</span><span class="delimiter">'</span></span>).
           order().by(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>).values(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>) <span class="invisible">//</span><b class="conum">4</b><span class="invisible">\</span>
==&gt;C
==&gt;D
==&gt;E</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Find all the events in 2016.</p>
</li>
<li>
<p>Find all the events in May of 2016.</p>
</li>
<li>
<p>Find all the events on May 31, 2016.</p>
</li>
<li>
<p>Find all the events between May 31, 2016 and June 1, 2016.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="olap-spark-yarn">OLAP traversals with Spark on YARN</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TinkerPop&#8217;s combination of <a href="http://tinkerpop.apache.org/docs/3.3.1/reference/#sparkgraphcomputer">SparkGraphComputer</a>
and <a href="http://tinkerpop.apache.org/docs/3.3.1/reference/#_properties_files">HadoopGraph</a> allows for running
distributed, analytical graph queries (OLAP) on a computer cluster. The
<a href="http://tinkerpop.apache.org/docs/3.3.1/reference/#sparkgraphcomputer">reference documentation</a> covers the cases
where Spark runs locally or where the cluster is managed by a Spark server. However, many users can only run OLAP jobs
via the <a href="http://hadoop.apache.org/">Hadoop 2.x</a> Resource Manager (YARN), which requires <code>SparkGraphComputer</code> to be
configured differently. This recipe describes this configuration.</p>
</div>
<div class="sect2">
<h3 id="_approach">Approach</h3>
<div class="paragraph">
<p>Most configuration problems of TinkerPop with Spark on YARN stem from three reasons:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>SparkGraphComputer</code> creates its own <code>SparkContext</code> so it does not get any configs from the usual <code>spark-submit</code> command.</p>
</li>
<li>
<p>The TinkerPop Spark plugin did not include Spark on YARN runtime dependencies until version 3.2.7/3.3.1.</p>
</li>
<li>
<p>Resolving reason 2 by adding the cluster&#8217;s Spark jars to the classpath may create all kinds of version
conflicts with the Tinkerpop dependencies.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The current recipe follows a minimalist approach in which no dependencies are added to the dependencies
included in the TinkerPop binary distribution. The Hadoop cluster&#8217;s Spark installation is completely ignored. This
approach minimizes the chance of dependency version conflicts.</p>
</div>
</div>
<div class="sect2">
<h3 id="_prerequisites">Prerequisites</h3>
<div class="paragraph">
<p>This recipe is suitable for both a real external and a local pseudo Hadoop cluster. While the recipe is maintained
for the vanilla Hadoop pseudo-cluster, it has been reported to work on real clusters with Hadoop distributions
from various vendors.</p>
</div>
<div class="paragraph">
<p>If you want to try the recipe on a local Hadoop pseudo-cluster, the easiest way to install
it is to look at the install script at <a href="https://github.com/apache/tinkerpop/blob/3.3.1/docker/hadoop/install.sh" class="bare">https://github.com/apache/tinkerpop/blob/3.3.1/docker/hadoop/install.sh</a>
and the <code>start hadoop</code> section of <a href="https://github.com/apache/tinkerpop/blob/3.3.1/docker/scripts/build.sh" class="bare">https://github.com/apache/tinkerpop/blob/3.3.1/docker/scripts/build.sh</a>.</p>
</div>
<div class="paragraph">
<p>This recipe assumes that you installed the Gremlin Console with the
<a href="http://tinkerpop.apache.org/docs/3.3.1/reference/#spark-plugin">Spark plugin</a> (the
<a href="http://tinkerpop.apache.org/docs/3.3.1/reference/#hadoop-plugin">Hadoop plugin</a> is optional). Your Hadoop cluster
may have been configured to use file compression, e.g. LZO compression. If so, you need to copy the relevant
jar (e.g. <code>hadoop-lzo-*.jar</code>) to Gremlin Console&#8217;s <code>ext/spark-gremlin/lib</code> folder.</p>
</div>
<div class="paragraph">
<p>For starting the Gremlin Console in the right environment, create a shell script (e.g. <code>bin/spark-yarn.sh</code>) with the
contents below. Of course, actual values for <code>GREMLIN_HOME</code>, <code>HADOOP_HOME</code> and <code>HADOOP_CONF_DIR</code> need to be adapted to
your particular environment.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>#!/bin/bash
# Variables to be adapted to the actual environment
GREMLIN_HOME=/home/yourdir/lib/apache-tinkerpop-gremlin-console-3.3.1-standalone
export HADOOP_HOME=/usr/local/lib/hadoop-2.7.2
export HADOOP_CONF_DIR=/usr/local/lib/hadoop-2.7.2/etc/hadoop

# Have TinkerPop find the hadoop cluster configs and hadoop native libraries
export CLASSPATH=$HADOOP_CONF_DIR
export JAVA_OPTIONS="-Djava.library.path=$HADOOP_HOME/lib/native:$HADOOP_HOME/lib/native/Linux-amd64-64"

# Start gremlin-console without getting the HADOOP_GREMLIN_LIBS warning
cd $GREMLIN_HOME
[ ! -e empty ] &amp;&amp; mkdir empty
export HADOOP_GREMLIN_LIBS=$GREMLIN_HOME/empty
bin/gremlin.sh</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_running_the_job">Running the job</h3>
<div class="paragraph">
<p>You can now run a gremlin OLAP query with Spark on YARN:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>$ hdfs dfs -put data/tinkerpop-modern.kryo .
$ . bin/spark-yarn.sh</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; hadoop = <span class="predefined-type">System</span>.getenv(<span class="string"><span class="delimiter">'</span><span class="content">HADOOP_HOME</span><span class="delimiter">'</span></span>)
gremlin&gt; hadoopConfDir = <span class="predefined-type">System</span>.getenv(<span class="string"><span class="delimiter">'</span><span class="content">HADOOP_CONF_DIR</span><span class="delimiter">'</span></span>)
gremlin&gt; archive = <span class="string"><span class="delimiter">'</span><span class="content">spark-gremlin.zip</span><span class="delimiter">'</span></span>
==&gt;spark-gremlin.zip
gremlin&gt; archivePath = <span class="string"><span class="delimiter">&quot;</span><span class="content">/tmp/</span><span class="inline"><span class="inline-delimiter">$</span>archive</span><span class="delimiter">&quot;</span></span>
==&gt;<span class="regexp"><span class="delimiter">/</span><span class="content">tmp</span><span class="delimiter">/</span></span>spark-gremlin.zip
gremlin&gt; [<span class="string"><span class="delimiter">'</span><span class="content">bash</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">-c</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">rm -f </span><span class="inline"><span class="inline-delimiter">$</span>archivePath</span><span class="content">; cd ext/spark-gremlin/lib &amp;&amp; zip </span><span class="inline"><span class="inline-delimiter">$</span>archivePath</span><span class="content"> *.jar</span><span class="delimiter">&quot;</span></span>].execute().waitFor()
==&gt;<span class="integer">0</span>
gremlin&gt; conf = <span class="keyword">new</span> PropertiesConfiguration(<span class="string"><span class="delimiter">'</span><span class="content">conf/hadoop/hadoop-gryo.properties</span><span class="delimiter">'</span></span>)
==&gt;org.apache.commons.configuration.PropertiesConfiguration<span class="error">@</span><span class="float">3664f</span><span class="integer">108</span>
gremlin&gt; conf.setProperty(<span class="string"><span class="delimiter">'</span><span class="content">spark.master</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">yarn</span><span class="delimiter">'</span></span>)
gremlin&gt; conf.setProperty(<span class="string"><span class="delimiter">'</span><span class="content">spark.submit.deployMode</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">client</span><span class="delimiter">'</span></span>)
gremlin&gt; conf.setProperty(<span class="string"><span class="delimiter">'</span><span class="content">spark.yarn.archive</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>archivePath</span><span class="delimiter">&quot;</span></span>)
gremlin&gt; conf.setProperty(<span class="string"><span class="delimiter">'</span><span class="content">spark.yarn.appMasterEnv.CLASSPATH</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">./__spark_libs__/*:</span><span class="inline"><span class="inline-delimiter">$</span>hadoopConfDir</span><span class="delimiter">&quot;</span></span>)
gremlin&gt; conf.setProperty(<span class="string"><span class="delimiter">'</span><span class="content">spark.executor.extraClassPath</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">./__spark_libs__/*:</span><span class="inline"><span class="inline-delimiter">$</span>hadoopConfDir</span><span class="delimiter">&quot;</span></span>)
gremlin&gt; conf.setProperty(<span class="string"><span class="delimiter">'</span><span class="content">spark.driver.extraLibraryPath</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>hadoop</span><span class="content">/lib/native:</span><span class="inline"><span class="inline-delimiter">$</span>hadoop</span><span class="content">/lib/native/Linux-amd64-64</span><span class="delimiter">&quot;</span></span>)
gremlin&gt; conf.setProperty(<span class="string"><span class="delimiter">'</span><span class="content">spark.executor.extraLibraryPath</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">$</span>hadoop</span><span class="content">/lib/native:</span><span class="inline"><span class="inline-delimiter">$</span>hadoop</span><span class="content">/lib/native/Linux-amd64-64</span><span class="delimiter">&quot;</span></span>)
gremlin&gt; conf.setProperty(<span class="string"><span class="delimiter">'</span><span class="content">gremlin.spark.persistContext</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">true</span><span class="delimiter">'</span></span>)
gremlin&gt; graph = GraphFactory.open(conf)
==&gt;hadoopgraph[gryoinputformat-&gt;gryooutputformat]
gremlin&gt; g = graph.traversal().withComputer(SparkGraphComputer)
==&gt;graphtraversalsource[hadoopgraph[gryoinputformat-&gt;gryooutputformat], sparkgraphcomputer]
gremlin&gt; g.V().group().by(values(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>)).by(both().count())
==&gt;[<span class="key">ripple</span>:<span class="integer">1</span>,<span class="key">peter</span>:<span class="integer">1</span>,<span class="key">vadas</span>:<span class="integer">1</span>,<span class="key">josh</span>:<span class="integer">3</span>,<span class="key">lop</span>:<span class="integer">3</span>,<span class="key">marko</span>:<span class="integer">3</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you run into exceptions, you will have to dig into the logs. You can do this from the command line with
<code>yarn application -list -appStates ALL</code> to find the <code>applicationId</code>, while the logs are available with
<code>yarn logs -applicationId application_1498627870374_0008</code>. Alternatively, you can inspect the logs via
the YARN Resource Manager UI (e.g. http://rm.your.domain:8088/cluster), provided that YARN was configured with the
<code>yarn.log-aggregation-enable</code> property set to <code>true</code>. See the Spark documentation for
<a href="https://spark.apache.org/docs/latest/running-on-yarn.html#debugging-your-application">additional hints</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_explanation">Explanation</h3>
<div class="paragraph">
<p>This recipe does not require running the <code>bin/hadoop/init-tp-spark.sh</code> script described in the
<a href="http://tinkerpop.apache.org/docs/3.3.1/reference/#sparkgraphcomputer">reference documentation</a> and thus is also
valid for cluster users without access permissions to do so.</p>
</div>
<div class="paragraph">
<p>Rather, it exploits the <code>spark.yarn.archive</code> property, which points to an archive with jars on the local file
system and is loaded into the various YARN containers. As a result the <code>spark-gremlin.zip</code> archive becomes available
as the directory named <code>__spark_libs__</code> in the YARN containers. The <code>spark.executor.extraClassPath</code> and
<code>spark.yarn.appMasterEnv.CLASSPATH</code> properties point to the jars inside this directory.
This is why they contain the <code>./__spark_lib__/*</code> item. Just because a Spark executor got the archive with
jars loaded into its container, does not mean it knows how to access them.</p>
</div>
<div class="paragraph">
<p>Also the <code>HADOOP_GREMLIN_LIBS</code> mechanism is not used because it can not work for Spark on YARN as implemented (jars
added to the <code>SparkContext</code> are not available to the YARN application master).</p>
</div>
<div class="paragraph">
<p>The <code>gremlin.spark.persistContext</code> property is explained in the reference documentation of
<a href="http://tinkerpop.apache.org/docs/3.3.1/reference/#sparkgraphcomputer">SparkGraphComputer</a>: it helps in getting
follow-up OLAP queries answered faster, because you skip the overhead for getting resources from YARN.</p>
</div>
</div>
<div class="sect2">
<h3 id="_additional_configuration_options">Additional configuration options</h3>
<div class="paragraph">
<p>This recipe does most of the graph configuration in the Gremlin Console so that environment variables can be used and
the chance of configuration mistakes is minimal. Once you have your setup working, it is probably easier to make a copy
of the <code>conf/hadoop/hadoop-gryo.properties</code> file and put the property values specific to your environment there. This is
also the right moment to take a look at the <code>spark-defaults.xml</code> file of your cluster, in particular the settings for
the <a href="https://spark.apache.org/docs/latest/monitoring.html">Spark History Service</a>, which allows you to access logs of
finished applications via the YARN resource manager UI.</p>
</div>
<div class="paragraph">
<p>This recipe uses the Gremlin Console, but things should not be very different for your own JVM-based application,
as long as you do not use the <code>spark-submit</code> or <code>spark-shell</code> commands. You will also want to check the additional
runtime dependencies listed in the <code>Gremlin-Plugin-Dependencies</code> section of the manifest file in the <code>spark-gremlin</code>
jar.</p>
</div>
<div class="paragraph">
<p>You may not like the idea that the Hadoop and Spark jars from the Tinkerpop distribution differ from the versions in
your cluster. If so, just build TinkerPop from source with the corresponding dependencies changed in the various <code>pom.xml</code>
files (e.g. <code>spark-core_2.11-2.2.0-some-vendor.jar</code> instead of <code>spark-core_2.11-2.2.0.jar</code>). Of course, TinkerPop will
only build for exactly matching or slightly differing artifact versions.</p>
</div>
</div>
</div>
</div>
<h1 id="_implementation_recipes" class="sect0">Implementation Recipes</h1>
<div class="sect1">
<h2 id="style-guide">Style Guide</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gremlin is a data flow language where each new step concatenation alters the stream accordingly. This aspect of the
language allows users to easily "build-up" a traversal (literally) step-by-step until the expected results are
returned. For instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V(<span class="integer">1</span>)
==&gt;v[<span class="integer">1</span>]
gremlin&gt; g.V(<span class="integer">1</span>).out(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>)
==&gt;v[<span class="integer">2</span>]
==&gt;v[<span class="integer">4</span>]
gremlin&gt; g.V(<span class="integer">1</span>).out(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).out(<span class="string"><span class="delimiter">'</span><span class="content">created</span><span class="delimiter">'</span></span>)
==&gt;v[<span class="integer">5</span>]
==&gt;v[<span class="integer">3</span>]
gremlin&gt; g.V(<span class="integer">1</span>).out(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).out(<span class="string"><span class="delimiter">'</span><span class="content">created</span><span class="delimiter">'</span></span>).groupCount()
==&gt;[v[<span class="integer">3</span>]:<span class="integer">1</span>,v[<span class="integer">5</span>]:<span class="integer">1</span>]
gremlin&gt; g.V(<span class="integer">1</span>).out(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).out(<span class="string"><span class="delimiter">'</span><span class="content">created</span><span class="delimiter">'</span></span>).groupCount().by(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>)
==&gt;[<span class="key">ripple</span>:<span class="integer">1</span>,<span class="key">lop</span>:<span class="integer">1</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>A drawback of building up a traversal is that users tend to create long, single line traversal that are hard to read.
For simple traversals, a single line is fine. For complex traversals, there are few formatting patterns that should be followed
which will yield cleaner, easier to understand traversals. For instance, the last traversal above would be written:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V(<span class="integer">1</span>).out(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).out(<span class="string"><span class="delimiter">'</span><span class="content">created</span><span class="delimiter">'</span></span>).
           groupCount().by(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>)
==&gt;[<span class="key">ripple</span>:<span class="integer">1</span>,<span class="key">lop</span>:<span class="integer">1</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lets look at a complex traversal and analyze each line according to the recommended formatting rule is subscribes to.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().out(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).out(<span class="string"><span class="delimiter">'</span><span class="content">created</span><span class="delimiter">'</span></span>). <span class="invisible">//</span><b class="conum">1</b><span class="invisible">\</span>
           group().by(<span class="string"><span class="delimiter">'</span><span class="content">lang</span><span class="delimiter">'</span></span>).by(). <span class="invisible">//</span><b class="conum">2</b><span class="invisible">\</span>
             select(<span class="string"><span class="delimiter">'</span><span class="content">java</span><span class="delimiter">'</span></span>).unfold(). <span class="invisible">//</span><b class="conum">3</b><span class="invisible">\</span>
           <span class="keyword">in</span>(<span class="string"><span class="delimiter">'</span><span class="content">created</span><span class="delimiter">'</span></span>).hasLabel(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>). <span class="invisible">//</span><b class="conum">4</b><span class="invisible">\</span>
           order(). <span class="invisible">//</span><b class="conum">5</b><span class="invisible">\</span>
             by(inE().count(),decr). <span class="invisible">//</span><b class="conum">6</b><span class="invisible">\</span>
             by(<span class="string"><span class="delimiter">'</span><span class="content">age</span><span class="delimiter">'</span></span>,incr).
           dedup().limit(<span class="integer">10</span>).values(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>) <span class="invisible">//</span><b class="conum">7</b><span class="invisible">\</span>
==&gt;josh
==&gt;marko
==&gt;peter</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A sequence of <code>ins().outs().filters().etc()</code> on a single line until it gets too long.</p>
</li>
<li>
<p>When a barrier (reducer, aggregator, etc.) is used, put it on a new line.</p>
</li>
<li>
<p>When a next line component is an "add on" to the previous line component, 2 space indent.
The <code>select()</code>-step in this context is "almost like" a <code>by()</code>-modulator as its projecting data out of the <code>group()</code>.
The <code>unfold()</code>-step is a data formatting necessity that should not be made too prominent.</p>
</li>
<li>
<p>Back to a series of <code>ins().outs().filters().etc()</code> on a single line.</p>
</li>
<li>
<p><code>order()</code> is a barrier step and thus, should be on a new line.</p>
</li>
<li>
<p>If there is only one <code>by()</code>-modulator (or a series of short ones), keep it on one line, else each <code>by()</code> is a new line.</p>
</li>
<li>
<p>Back to a series <code>ins().outs().filters().etc()</code>.</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_style_guide_rules">Style Guide Rules</h3>
<div class="paragraph">
<p>A generalization of the specifics above are presented below.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Always use 2 space indent.</p>
</li>
<li>
<p>No newline should ever have the same indent as the line starting with the traversal source <code>g</code>.</p>
</li>
<li>
<p>Barrier steps should form line breaks unless they are simple (e.g. <code>sum()</code>).</p>
</li>
<li>
<p>Complex <code>by()</code>-modulators form indented "paragraphs."</p>
</li>
<li>
<p>Standard filters, maps, flatMaps remain on the same line until they get too long.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Given the diversity of traversals and the complexities introduced by lambdas (for example), these rules will not always
lead to optimal representations. However, by in large, the style rules above will help make 90% of traversals look great.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="traversal-component-reuse">Traversal Component Reuse</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Good software development practices require reuse to keep software maintainable. In Gremlin, there are often bits of
traversal logic that could be represented as components that might be tested independently and utilized
as part of other traversals. One approach to doing this would be to extract such logic into an anonymous traversal
and provide it to a parent traversal through <code>flatMap()</code> step.</p>
</div>
<div class="paragraph">
<p>Using the modern toy graph as an example, assume that there are number of traversals that are interested in filtering
on edges where the "weight" property is greater than "0.5". A query like that might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V(<span class="integer">1</span>).outE(<span class="string"><span class="delimiter">&quot;</span><span class="content">knows</span><span class="delimiter">&quot;</span></span>).has(<span class="string"><span class="delimiter">'</span><span class="content">weight</span><span class="delimiter">'</span></span>, P.gt(<span class="float">0.5d</span>)).inV().both()
==&gt;v[<span class="integer">5</span>]
==&gt;v[<span class="integer">3</span>]
==&gt;v[<span class="integer">1</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Repeatedly requiring that filter on "weight" could lead to a lot of duplicate code, which becomes difficult to
maintain. It would be nice to extract that logic so as to centralize it for reuse in all places where needed. An
anonymous traversal allows that to happen and can be created as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; weightFilter = outE(<span class="string"><span class="delimiter">&quot;</span><span class="content">knows</span><span class="delimiter">&quot;</span></span>).has(<span class="string"><span class="delimiter">'</span><span class="content">weight</span><span class="delimiter">'</span></span>, P.gt(<span class="float">0.5d</span>)).inV();<span class="type">[]</span>
gremlin&gt; g.V(<span class="integer">1</span>).flatMap(weightFilter).both()
==&gt;v[<span class="integer">5</span>]
==&gt;v[<span class="integer">3</span>]
==&gt;v[<span class="integer">1</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>weightFilter</code> is an anonymous traversal and it is created by way <code><em></code> class. The <code></em></code> is omitted above from
initalization of <code>weightFilter</code> because it is statically imported to the Gremlin Console. The <code>weightFilter</code> gets
passed to the "full" traversal by way for <code>flatMap()</code> step and the results are the same. Of course, there is a problem.
If there is an attempt to use that <code>weightFilter</code> a second time, the traversal with thrown an exception because both
the <code>weightFilter</code> and parent traversal have been "compiled" which prevents their re-use. A simple fix to this would
be to clone the <code>weightFilter</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; weightFilter = outE(<span class="string"><span class="delimiter">&quot;</span><span class="content">knows</span><span class="delimiter">&quot;</span></span>).has(<span class="string"><span class="delimiter">'</span><span class="content">weight</span><span class="delimiter">'</span></span>, P.gt(<span class="float">0.5d</span>)).inV();<span class="type">[]</span>
gremlin&gt; g.V(<span class="integer">1</span>).flatMap(weightFilter.clone()).both()
==&gt;v[<span class="integer">5</span>]
==&gt;v[<span class="integer">3</span>]
==&gt;v[<span class="integer">1</span>]
gremlin&gt; g.V(<span class="integer">1</span>).flatMap(weightFilter.clone()).bothE().otherV()
==&gt;v[<span class="integer">5</span>]
==&gt;v[<span class="integer">3</span>]
==&gt;v[<span class="integer">1</span>]
gremlin&gt; g.V(<span class="integer">1</span>).flatMap(weightFilter.clone()).groupCount()
==&gt;[v[<span class="integer">4</span>]:<span class="integer">1</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now the <code>weightFilter</code> can be reused over and over again. Remembering to <code>clone()</code> might lead to yet another maintenance
issue in that failing to recall that step would likely result in a bug. One option might be to wrap the <code>weightFilter</code>
creation in a function that returns the clone. Another approach might be to parameterize that function to construct
a new anonymous traversal each time with the idea being that this might gain even more flexibility in parameterizing
the anonymous traversal itself.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; weightFilter = { w -&gt; outE(<span class="string"><span class="delimiter">&quot;</span><span class="content">knows</span><span class="delimiter">&quot;</span></span>).has(<span class="string"><span class="delimiter">'</span><span class="content">weight</span><span class="delimiter">'</span></span>, P.gt(w)).inV() }
==&gt;groovysh_evaluate<span class="error">$</span>_run_closure1<span class="error">@</span><span class="float">2f</span><span class="integer">14</span>b0f6
gremlin&gt; g.V(<span class="integer">1</span>).flatMap(weightFilter(<span class="float">0.5d</span>)).both()
==&gt;v[<span class="integer">5</span>]
==&gt;v[<span class="integer">3</span>]
==&gt;v[<span class="integer">1</span>]
gremlin&gt; g.V(<span class="integer">1</span>).flatMap(weightFilter(<span class="float">0.5d</span>)).bothE().otherV()
==&gt;v[<span class="integer">5</span>]
==&gt;v[<span class="integer">3</span>]
==&gt;v[<span class="integer">1</span>]
gremlin&gt; g.V(<span class="integer">1</span>).flatMap(weightFilter(<span class="float">0.5d</span>)).groupCount()
==&gt;[v[<span class="integer">4</span>]:<span class="integer">1</span>]</code></pre>
</div>
</div>
</div>
</div>
<h1 id="contributing" class="sect0">How to Contribute a Recipe</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>Recipes are generated under the same system as all TinkerPop documentation and is stored directly in the source code
repository. TinkerPop documentation is all <a href="http://asciidoc.org/">asciidoc</a> based and can be generated locally with
either <a href="http://tinkerpop.apache.org/docs/3.3.1/dev/developer/#building-testing">shell script/Maven</a> or
<a href="http://tinkerpop.apache.org/docs/3.3.1/dev/developer/#docker-integration">Docker</a> build commands. Once
changes are complete, submit a pull request for review by TinkerPop committers.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Please review existing recipes and attempt to conform to their writing and visual style. It may also be a good
idea to discuss ideas for a recipe on the <a href="https://lists.apache.org/list.html?dev@tinkerpop.apache.org">developer mailing list</a>
prior to starting work on it, as the community might provide insight on the approach and idea that would be helpful.
It is preferable that a <a href="https://issues.apache.org/jira/browse/TINKERPOP">JIRA issue</a> be opened that describes the nature
of the recipe so that the eventual pull request can be bound to that issue.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Please read TinkerPop&#8217;s <a href="http://tinkerpop.apache.org/docs/3.3.1/dev/developer/#_contributing">policy on contributing</a>
prior to submitting a recipe.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To contribute a recipe, first clone the repository:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">git clone https://github.com/apache/tinkerpop.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>The recipes can be found in this directory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">ls docs/src/recipes</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each recipe exists within a separate <code>.asciidoc</code> file.  The file name should match the name of the recipe. Recipe names
should be short, but descriptive (as they need to fit in the left-hand table of contents when generated). The
<code>index.asciidoc</code> is the parent document that "includes" the content of each individual recipe file. A recipe file is
included in the <code>index.asciidoc</code> with an entry like this: <code>include::my-recipe.asciidoc[]</code></p>
</div>
<div class="paragraph">
<p>Documentation should be generated locally for review prior to submitting a pull request. TinkerPop documentation is
"live" in that it is bound to a specific version when generated. Furthermore, code examples (those that are
<code>gremlin-groovy</code> based) are executed at document generation time with the results written directly into the output.
The following command will generate the documentation with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">bin/process-docs.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>The generated documentation can be found at <code>target/docs/htmlsingle/recipes</code>. This process can be long on the first
run of the documentation as it is generating all of the documentation locally (e.g. reference documentation,
tutorials, etc). To generate just the recipes, follow this process:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">bin/process-docs.sh -f docs/src/recipes</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>bin/process-docs.sh</code> approach requires that Hadoop is installed. To avoid that prerequisite, try using Docker:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">docker/build.sh -d</code></pre>
</div>
</div>
<div class="paragraph">
<p>The downside to using Docker is that the process will take longer as each run will require the entire documentation set
to be generated.</p>
</div>
<div class="paragraph">
<p>The final step to submitting a recipe is to issue a <a href="https://help.github.com/articles/using-pull-requests/">pull request through GitHub</a>.
It is helpful to prefix the name of the pull request with the JIRA issue number, so that TinkerPop&#8217;s automation between
GitHub and JIRA are linked.  As mentioned earlier in this section, the recipe will go under review by TinkerPop
committers prior to merging. This process may take several days to complete. We look forward to receiving your
submissions!</p>
</div>
</div>
</div>
<h1 id="_appendix" class="sect0">Appendix</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>Many of the recipes are based on questions and answers provided on the
<a href="https://groups.google.com/forum/#!forum/gremlin-users">gremlin-users mailing list</a> or on
<a href="http://stackoverflow.com/questions/tagged/gremlin">StackOverflow</a>. This section contains those traversals from
those sources that do not easily fit any particular pattern (i.e. a recipe), but are nonetheless interesting and thus
remain good tools for learning Gremlin.</p>
</div>
<div id="appendix-a" class="paragraph">
<p><em>For each person in a "follows" graph, determine the number of followers and list their names.</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.addV().property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>).
           addV().property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">josh</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">josh</span><span class="delimiter">'</span></span>).
           addV().property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">daniel</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">daniel</span><span class="delimiter">'</span></span>).
           addV().property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">matthias</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">matthias</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">follows</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">josh</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">follows</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">matthias</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">josh</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">follows</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">daniel</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">josh</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">follows</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">daniel</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>).iterate()
gremlin&gt; g.V().as(<span class="string"><span class="delimiter">'</span><span class="content">p</span><span class="delimiter">'</span></span>).
           map(__.in(<span class="string"><span class="delimiter">'</span><span class="content">follows</span><span class="delimiter">'</span></span>).values(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>).fold()).
           project(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">followers</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">numFollowers</span><span class="delimiter">'</span></span>).
             by(select(<span class="string"><span class="delimiter">'</span><span class="content">p</span><span class="delimiter">'</span></span>).by(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>)).
             by().
             by(count(local))
==&gt;[<span class="key">person</span>:marko,<span class="key">followers</span>:[josh,daniel],<span class="key">numFollowers</span>:<span class="integer">2</span>]
==&gt;[<span class="key">person</span>:josh,<span class="key">followers</span>:[matthias,daniel],<span class="key">numFollowers</span>:<span class="integer">2</span>]
==&gt;[<span class="key">person</span>:daniel,<span class="key">followers</span>:<span class="type">[]</span>,<span class="key">numFollowers</span>:<span class="integer">0</span>]
==&gt;[<span class="key">person</span>:matthias,<span class="key">followers</span>:<span class="type">[]</span>,<span class="key">numFollowers</span>:<span class="integer">0</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>It might also be alternatively written as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().group().
                 by(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>).
                 by(project(<span class="string"><span class="delimiter">'</span><span class="content">numFollowers</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">followers</span><span class="delimiter">'</span></span>).
                      by(__.in(<span class="string"><span class="delimiter">'</span><span class="content">follows</span><span class="delimiter">'</span></span>).count()).
                      by(__.in(<span class="string"><span class="delimiter">'</span><span class="content">follows</span><span class="delimiter">'</span></span>).values(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>).fold())).next()
==&gt;daniel={numFollowers=<span class="integer">0</span>, followers=<span class="type">[]</span>}
==&gt;matthias={numFollowers=<span class="integer">0</span>, followers=<span class="type">[]</span>}
==&gt;josh={numFollowers=<span class="integer">2</span>, followers=[matthias, daniel]}
==&gt;marko={numFollowers=<span class="integer">2</span>, followers=[josh, daniel]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or even:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().group().
                 by(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>).
                 by(__.in(<span class="string"><span class="delimiter">'</span><span class="content">follows</span><span class="delimiter">'</span></span>).values(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>).fold().
                     project(<span class="string"><span class="delimiter">'</span><span class="content">numFollowers</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">followers</span><span class="delimiter">'</span></span>).
                       by(count(local)).
                       by()).next()
==&gt;daniel={numFollowers=<span class="integer">0</span>, followers=<span class="type">[]</span>}
==&gt;matthias={numFollowers=<span class="integer">0</span>, followers=<span class="type">[]</span>}
==&gt;josh={numFollowers=<span class="integer">2</span>, followers=[matthias, daniel]}
==&gt;marko={numFollowers=<span class="integer">2</span>, followers=[josh, daniel]}</code></pre>
</div>
</div>
<div id="appendix-b" class="paragraph">
<p><em>In the "modern" graph, show each person, the software they worked on and the co-worker count for the software and
the names of those co-workers.</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().hasLabel(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">p</span><span class="delimiter">&quot;</span></span>).
           out(<span class="string"><span class="delimiter">&quot;</span><span class="content">created</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">s</span><span class="delimiter">&quot;</span></span>).
           map(__.in(<span class="string"><span class="delimiter">&quot;</span><span class="content">created</span><span class="delimiter">&quot;</span></span>).
             where(neq(<span class="string"><span class="delimiter">&quot;</span><span class="content">p</span><span class="delimiter">&quot;</span></span>)).values(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>).fold()).
           group().by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">p</span><span class="delimiter">&quot;</span></span>).by(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>)).
             by(group().by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">s</span><span class="delimiter">&quot;</span></span>).by(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>)).
             by(project(<span class="string"><span class="delimiter">&quot;</span><span class="content">numCoworkers</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">coworkers</span><span class="delimiter">&quot;</span></span>).
                  by(count(local)).by())).next()
==&gt;peter={lop={numCoworkers=<span class="integer">2</span>, coworkers=[marko, josh]}}
==&gt;josh={ripple={numCoworkers=<span class="integer">0</span>, coworkers=<span class="type">[]</span>}, lop={numCoworkers=<span class="integer">2</span>, coworkers=[marko, peter]}}
==&gt;marko={lop={numCoworkers=<span class="integer">2</span>, coworkers=[josh, peter]}}</code></pre>
</div>
</div>
<div id="appendix-c" class="paragraph">
<p><em>Assuming a graph of students, classes and times, detect students who have a conflicting schedule.</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">student</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Pete</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">s1</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">student</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">s2</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">class</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Java's GC</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">c1</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">class</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">FP Principles</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">c2</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">class</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Memory Management in C</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">c3</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">class</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Memory Management in C++</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">c4</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">timeslot</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">11/25/2016</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">fromTime</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">10:00</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">toTime</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">11:00</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">t1</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">timeslot</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">11/25/2016</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">fromTime</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">11:00</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">toTime</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">12:00</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">t2</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">attends</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">s1</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">c1</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">attends</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">s1</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">c2</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">attends</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">s1</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">c3</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">attends</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">s1</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">c4</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">attends</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">s2</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">c2</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">attends</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">s2</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">c3</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">allocated</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">c1</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">t1</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">allocated</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">c1</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">t2</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">allocated</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">c2</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">t1</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">allocated</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">c3</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">t2</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">allocated</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">c4</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">t2</span><span class="delimiter">&quot;</span></span>).iterate()
gremlin&gt; g.V().hasLabel(<span class="string"><span class="delimiter">&quot;</span><span class="content">student</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">s</span><span class="delimiter">&quot;</span></span>).
           out(<span class="string"><span class="delimiter">&quot;</span><span class="content">attends</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>).
           out(<span class="string"><span class="delimiter">&quot;</span><span class="content">allocated</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>).
           select(<span class="string"><span class="delimiter">&quot;</span><span class="content">s</span><span class="delimiter">&quot;</span></span>).
           out(<span class="string"><span class="delimiter">&quot;</span><span class="content">attends</span><span class="delimiter">&quot;</span></span>).
           where(neq(<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>)).
           out(<span class="string"><span class="delimiter">&quot;</span><span class="content">allocated</span><span class="delimiter">&quot;</span></span>).
           where(eq(<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)).
           group().
             by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">s</span><span class="delimiter">&quot;</span></span>).by(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>)).
             by(group().by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>).by(valueMap(<span class="string"><span class="delimiter">&quot;</span><span class="content">fromTime</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">toTime</span><span class="delimiter">&quot;</span></span>))).
                        by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>).dedup().values(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>).fold())).next()
==&gt;Pete={{fromTime=[<span class="integer">10</span>:<span class="octal">00</span>], toTime=[<span class="integer">11</span>:<span class="octal">00</span>]}=[Java<span class="string"><span class="delimiter">'</span><span class="content">s GC, FP Principles], {fromTime=[11:00], toTime=[12:00]}=[Memory Management in C, Memory Management in C++, Java</span><span class="delimiter">'</span></span>s GC]}</code></pre>
</div>
</div>
<div id="appendix-d" class="paragraph">
<p><em>In the "modern" graph, with a duplicate edge added, find the vertex pairs that have more than one edge between them.</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V(<span class="integer">1</span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).V(<span class="integer">3</span>).addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">created</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">weight</span><span class="delimiter">&quot;</span></span>,<span class="float">0.4d</span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).iterate()
gremlin&gt; g.V(<span class="integer">1</span>).outE(<span class="string"><span class="delimiter">&quot;</span><span class="content">created</span><span class="delimiter">&quot;</span></span>)
==&gt;e[<span class="integer">9</span>][<span class="integer">1</span>-created-&gt;<span class="integer">3</span>]
==&gt;e[<span class="integer">13</span>][<span class="integer">1</span>-created-&gt;<span class="integer">3</span>]
gremlin&gt; g.V().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).
           out().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).
           groupCount().
             by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>)).
           unfold().
           filter(select(values).is(gt(<span class="integer">1</span>))).
           select(keys)
==&gt;[<span class="key">a</span>:v[<span class="integer">1</span>],<span class="key">b</span>:v[<span class="integer">3</span>]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example assumes that the edges point in the <code>OUT</code> direction. Assuming undirected edges:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().where(without(<span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span>)).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).
           outE().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">e</span><span class="delimiter">&quot;</span></span>).inV().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).
           filter(bothE().where(neq(<span class="string"><span class="delimiter">&quot;</span><span class="content">e</span><span class="delimiter">&quot;</span></span>)).otherV().where(eq(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>))).store(<span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span>).
           select(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).dedup()</code></pre>
</div>
</div>
<div id="appendix-e" class="paragraph">
<p><em>In the "crew" graph, find vertices that match on a complete set of multi-properties.</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; places = [<span class="string"><span class="delimiter">&quot;</span><span class="content">centreville</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">dulles</span><span class="delimiter">&quot;</span></span>];<span class="type">[]</span>  <span class="comment">// will not match as &quot;purcellville&quot; is missing</span>
gremlin&gt; g.V().not(has(<span class="string"><span class="delimiter">&quot;</span><span class="content">location</span><span class="delimiter">&quot;</span></span>, without(places))).
           where(values(<span class="string"><span class="delimiter">&quot;</span><span class="content">location</span><span class="delimiter">&quot;</span></span>).is(within(places)).count().is(places.size())).
           valueMap()
gremlin&gt; places = [<span class="string"><span class="delimiter">&quot;</span><span class="content">centreville</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">dulles</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">purcellville</span><span class="delimiter">&quot;</span></span>];<span class="type">[]</span>
gremlin&gt; g.V().not(has(<span class="string"><span class="delimiter">&quot;</span><span class="content">location</span><span class="delimiter">&quot;</span></span>, without(places))).
           where(values(<span class="string"><span class="delimiter">&quot;</span><span class="content">location</span><span class="delimiter">&quot;</span></span>).is(within(places)).count().is(places.size())).
           valueMap()
==&gt;[<span class="key">name</span>:[stephen],<span class="key">location</span>:[centreville,dulles,purcellville]]</code></pre>
</div>
</div>
<div id="appendix-f" class="paragraph">
<p><em>Methods for performing some basic mathematical operations in the "modern" graph.</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().values(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>).sum() <span class="comment">// sum all ages</span>
==&gt;<span class="integer">123</span>
gremlin&gt; g.V().values(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>).fold(<span class="integer">1</span>, mult) <span class="comment">// multiply all ages</span>
==&gt;<span class="integer">876960</span>
gremlin&gt; g.withSack(<span class="integer">0</span>).V().values(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>).sack(sum).sack(sum).by(constant(-<span class="integer">1</span>)).sack() <span class="comment">// subtract 1</span>
==&gt;<span class="integer">28</span>
==&gt;<span class="integer">26</span>
==&gt;<span class="integer">31</span>
==&gt;<span class="integer">34</span>
gremlin&gt; g.withSack(<span class="integer">0</span>).V().values(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>).sack(sum).sack(sum).sack() <span class="comment">// multiply by 2 (simple)</span>
==&gt;<span class="integer">58</span>
==&gt;<span class="integer">54</span>
==&gt;<span class="integer">64</span>
==&gt;<span class="integer">70</span>
gremlin&gt; g.withSack(<span class="integer">0</span>).V().values(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>).sack(sum).sack(mult).by(constant(<span class="integer">2</span>)).sack() <span class="comment">// multiply by 2 (generally useful for multiplications by n)</span>
==&gt;<span class="integer">58</span>
==&gt;<span class="integer">54</span>
==&gt;<span class="integer">64</span>
==&gt;<span class="integer">70</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Method for doing a sum with division.</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.addV().property(id, <span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).
           addV().property(id, <span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">link</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">link</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">link</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).iterate()
gremlin&gt; g.withSack(<span class="float">0d</span>).
            V(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).
            V(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).
              project(<span class="string"><span class="delimiter">&quot;</span><span class="content">ab</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">ba</span><span class="delimiter">&quot;</span></span>).
                by(inE(<span class="string"><span class="delimiter">&quot;</span><span class="content">link</span><span class="delimiter">&quot;</span></span>).where(outV().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>)).count()).
                by(outE(<span class="string"><span class="delimiter">&quot;</span><span class="content">link</span><span class="delimiter">&quot;</span></span>).where(inV().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>)).count()).
              sack(sum).by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">ab</span><span class="delimiter">&quot;</span></span>)).
              sack(div).by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">ba</span><span class="delimiter">&quot;</span></span>)).
              project(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">#(a,b)</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">#(b,a)</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">#(a,b) / #(b,a)</span><span class="delimiter">&quot;</span></span>).
                by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>)).
                by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>)).
                by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">ab</span><span class="delimiter">&quot;</span></span>)).
                by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">ba</span><span class="delimiter">&quot;</span></span>)).
                by(sack())
==&gt;[<span class="key">a</span>:v[a],<span class="key">b</span>:v[b],<span class="error">#</span>(a,b):<span class="integer">1</span>,<span class="error">#</span>(b,a):<span class="integer">2</span>,<span class="error">#</span>(a,b) / <span class="error">#</span>(b,a):<span class="float">0.5</span>]</code></pre>
</div>
</div>
<div id="appendix-g" class="paragraph">
<p><em>Dropping a vertex, as well as the vertices related to that dropped vertex that are connected by a "knows" edge in the
"modern" graph</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>).outE()
==&gt;e[<span class="integer">9</span>][<span class="integer">1</span>-created-&gt;<span class="integer">3</span>]
==&gt;e[<span class="integer">7</span>][<span class="integer">1</span>-knows-&gt;<span class="integer">2</span>]
==&gt;e[<span class="integer">8</span>][<span class="integer">1</span>-knows-&gt;<span class="integer">4</span>]
gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>).sideEffect(out(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).drop()).drop()
gremlin&gt; g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>)
gremlin&gt; g.V(<span class="integer">2</span>,<span class="integer">4</span>,<span class="integer">3</span>)
==&gt;v[<span class="integer">3</span>]</code></pre>
</div>
</div>
<div id="appendix-h" class="paragraph">
<p><em>For the specified graph, find all neighbor vertices connected to "A" as filtered by datetime, those neighbor vertices
that don&#8217;t have datetime vertices, and those neighbor vertices that have the label "dimon".</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.addV().property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).
           addV().property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">B</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).
           addV().property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">C</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>).
           addV().property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">D</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">d</span><span class="delimiter">&quot;</span></span>).
           addV().property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">E</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">e</span><span class="delimiter">&quot;</span></span>).
           addV(<span class="string"><span class="delimiter">&quot;</span><span class="content">dimon</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">F</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">f</span><span class="delimiter">&quot;</span></span>).
           addV().property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">G</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">g</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>, <span class="integer">20160818</span>).
           addV().property(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">H</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">h</span><span class="delimiter">&quot;</span></span>).property(<span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>, <span class="integer">20160817</span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">rel</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">rel</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">rel</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">d</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">rel</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">e</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">rel</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">f</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">occured_at</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">d</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">g</span><span class="delimiter">&quot;</span></span>).
           addE(<span class="string"><span class="delimiter">&quot;</span><span class="content">occured_at</span><span class="delimiter">&quot;</span></span>).from(<span class="string"><span class="delimiter">&quot;</span><span class="content">e</span><span class="delimiter">&quot;</span></span>).to(<span class="string"><span class="delimiter">&quot;</span><span class="content">h</span><span class="delimiter">&quot;</span></span>).iterate()
gremlin&gt; <span class="comment">// D and E have a valid datetime</span>
==&gt;<span class="predefined-constant">true</span>
gremlin&gt; g.V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>).out(<span class="string"><span class="delimiter">&quot;</span><span class="content">rel</span><span class="delimiter">&quot;</span></span>).
           union(where(out(<span class="string"><span class="delimiter">&quot;</span><span class="content">occured_at</span><span class="delimiter">&quot;</span></span>).has(<span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>, gte(<span class="integer">20160817</span>))),
                 __.not(outE(<span class="string"><span class="delimiter">&quot;</span><span class="content">occured_at</span><span class="delimiter">&quot;</span></span>)).coalesce(out().hasLabel(<span class="string"><span class="delimiter">&quot;</span><span class="content">dimon</span><span class="delimiter">&quot;</span></span>), identity())).
           valueMap()
==&gt;[<span class="key">name</span>:[B]]
==&gt;[<span class="key">name</span>:[F]]
==&gt;[<span class="key">name</span>:[D]]
==&gt;[<span class="key">name</span>:[E]]
gremlin&gt; <span class="comment">// only E has a valid date</span>
==&gt;<span class="predefined-constant">true</span>
gremlin&gt; g.V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>).out(<span class="string"><span class="delimiter">&quot;</span><span class="content">rel</span><span class="delimiter">&quot;</span></span>).
           union(where(out(<span class="string"><span class="delimiter">&quot;</span><span class="content">occured_at</span><span class="delimiter">&quot;</span></span>).has(<span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>, lte(<span class="integer">20160817</span>))),
                 __.not(outE(<span class="string"><span class="delimiter">&quot;</span><span class="content">occured_at</span><span class="delimiter">&quot;</span></span>)).coalesce(out().hasLabel(<span class="string"><span class="delimiter">&quot;</span><span class="content">dimon</span><span class="delimiter">&quot;</span></span>), identity())).
           valueMap()
==&gt;[<span class="key">name</span>:[B]]
==&gt;[<span class="key">name</span>:[F]]
==&gt;[<span class="key">name</span>:[E]]
gremlin&gt; <span class="comment">// only D has a valid date</span>
==&gt;<span class="predefined-constant">true</span>
gremlin&gt; g.V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>).out(<span class="string"><span class="delimiter">&quot;</span><span class="content">rel</span><span class="delimiter">&quot;</span></span>).
           union(where(out(<span class="string"><span class="delimiter">&quot;</span><span class="content">occured_at</span><span class="delimiter">&quot;</span></span>).has(<span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>, gt(<span class="integer">20160817</span>))),
                 __.not(outE(<span class="string"><span class="delimiter">&quot;</span><span class="content">occured_at</span><span class="delimiter">&quot;</span></span>)).coalesce(out().hasLabel(<span class="string"><span class="delimiter">&quot;</span><span class="content">dimon</span><span class="delimiter">&quot;</span></span>), identity())).
           valueMap()
==&gt;[<span class="key">name</span>:[B]]
==&gt;[<span class="key">name</span>:[F]]
==&gt;[<span class="key">name</span>:[D]]
gremlin&gt; <span class="comment">// neither D nor E have a valid date</span>
==&gt;<span class="predefined-constant">true</span>
gremlin&gt; g.V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>).out(<span class="string"><span class="delimiter">&quot;</span><span class="content">rel</span><span class="delimiter">&quot;</span></span>).
           union(where(out(<span class="string"><span class="delimiter">&quot;</span><span class="content">occured_at</span><span class="delimiter">&quot;</span></span>).has(<span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>, lt(<span class="integer">20160817</span>))),
                 __.not(outE(<span class="string"><span class="delimiter">&quot;</span><span class="content">occured_at</span><span class="delimiter">&quot;</span></span>)).coalesce(out().hasLabel(<span class="string"><span class="delimiter">&quot;</span><span class="content">dimon</span><span class="delimiter">&quot;</span></span>), identity())).
           valueMap()
==&gt;[<span class="key">name</span>:[B]]
==&gt;[<span class="key">name</span>:[F]]</code></pre>
</div>
</div>
<div id="appendix-i" class="paragraph">
<p><em>Use element labels in a <code>select</code>.</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.V(<span class="integer">1</span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).
           both().
           map(group().by(label).by(unfold())).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).
           select(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).
           map(union(project(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>)), select(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>)).
           unfold().
           group().
             by(select(keys)).
             by(select(values)))
==&gt;[<span class="key">a</span>:v[<span class="integer">1</span>],<span class="key">software</span>:v[<span class="integer">3</span>]]
==&gt;[<span class="key">a</span>:v[<span class="integer">1</span>],<span class="key">person</span>:v[<span class="integer">2</span>]]
==&gt;[<span class="key">a</span>:v[<span class="integer">1</span>],<span class="key">person</span>:v[<span class="integer">4</span>]]
gremlin&gt; g.V().as(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).
           both().
           map(group().by(label).by(unfold())).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).
           select(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).
           group().
             by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>)).
             by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).
                  group().
                    by(select(keys)).
                    by(select(values).fold())).
             unfold().
             map(union(select(keys).project(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).by(), select(values)).
             unfold().
             group().
               by(select(keys).unfold()).
               by(select(values).unfold().unfold().fold()))
==&gt;[<span class="key">a</span>:[v[<span class="integer">1</span>]],<span class="key">software</span>:[v[<span class="integer">3</span>]],<span class="key">person</span>:[v[<span class="integer">2</span>],v[<span class="integer">4</span>]]]
==&gt;[<span class="key">a</span>:[v[<span class="integer">2</span>]],<span class="key">person</span>:[v[<span class="integer">1</span>]]]
==&gt;[<span class="key">a</span>:[v[<span class="integer">3</span>]],<span class="key">person</span>:[v[<span class="integer">1</span>],v[<span class="integer">4</span>],v[<span class="integer">6</span>]]]
==&gt;[<span class="key">a</span>:[v[<span class="integer">4</span>]],<span class="key">software</span>:[v[<span class="integer">5</span>],v[<span class="integer">3</span>]],<span class="key">person</span>:[v[<span class="integer">1</span>]]]
==&gt;[<span class="key">a</span>:[v[<span class="integer">5</span>]],<span class="key">person</span>:[v[<span class="integer">4</span>]]]
==&gt;[<span class="key">a</span>:[v[<span class="integer">6</span>]],<span class="key">software</span>:[v[<span class="integer">3</span>]]]</code></pre>
</div>
</div>
<div id="appendix-j" class="paragraph">
<p><em>Sum edge weight with a coefficient.</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">gremlin&gt; g.addV(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">alice</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">alice</span><span class="delimiter">'</span></span>).
           addV(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">bobby</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">bobby</span><span class="delimiter">'</span></span>).
           addV(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">cindy</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">cindy</span><span class="delimiter">'</span></span>).
           addV(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">david</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">david</span><span class="delimiter">'</span></span>).
           addV(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">eliza</span><span class="delimiter">'</span></span>).as(<span class="string"><span class="delimiter">'</span><span class="content">eliza</span><span class="delimiter">'</span></span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">rates</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">alice</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">bobby</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">tag</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">ruby</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>,<span class="integer">9</span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">rates</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">bobby</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">cindy</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">tag</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">ruby</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>,<span class="integer">8</span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">rates</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">cindy</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">david</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">tag</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">ruby</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>,<span class="integer">7</span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">rates</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">david</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">eliza</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">tag</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">ruby</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>,<span class="integer">6</span>).
           addE(<span class="string"><span class="delimiter">'</span><span class="content">rates</span><span class="delimiter">'</span></span>).from(<span class="string"><span class="delimiter">'</span><span class="content">alice</span><span class="delimiter">'</span></span>).to(<span class="string"><span class="delimiter">'</span><span class="content">eliza</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">tag</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">java</span><span class="delimiter">'</span></span>).property(<span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>,<span class="integer">9</span>).iterate()
gremlin&gt;  g.withSack(<span class="float">1.0</span>).V().has(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">alice</span><span class="delimiter">&quot;</span></span>).
            repeat(outE(<span class="string"><span class="delimiter">&quot;</span><span class="content">rates</span><span class="delimiter">&quot;</span></span>).has(<span class="string"><span class="delimiter">&quot;</span><span class="content">tag</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">ruby</span><span class="delimiter">&quot;</span></span>).
                   project(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>).
                     by(inV()).
                     by(sack()).
                     by(<span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>).as(<span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span>).
                   select(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).
                   sack(mult).by(constant(<span class="float">0.5</span>))).
               times(<span class="integer">3</span>).emit().
             select(all, <span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span>).
             project(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">score</span><span class="delimiter">&quot;</span></span>).
               by(tail(local, <span class="integer">1</span>).select(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).values(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>)).
               by(unfold().
                  sack(assign).by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>)).
                  sack(mult).by(select(<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>)).
                  sack().sum())
==&gt;[<span class="key">name</span>:bobby,<span class="key">score</span>:<span class="float">9.0</span>]
==&gt;[<span class="key">name</span>:cindy,<span class="key">score</span>:<span class="float">13.00</span>]
==&gt;[<span class="key">name</span>:david,<span class="key">score</span>:<span class="float">14.750</span>]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2017-12-17 10:35:26 EST
</div>
</div>
</body>
</html>
